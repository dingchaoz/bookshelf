'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tsModuleType = require('typescript');

(function (SimpleTypeKind) {
    SimpleTypeKind["STRING_LITERAL"] = "STRING_LITERAL";
    SimpleTypeKind["NUMBER_LITERAL"] = "NUMBER_LITERAL";
    SimpleTypeKind["BOOLEAN_LITERAL"] = "BOOLEAN_LITERAL";
    SimpleTypeKind["BIG_INT_LITERAL"] = "BIG_INT_LITERAL";
    SimpleTypeKind["STRING"] = "STRING";
    SimpleTypeKind["NUMBER"] = "NUMBER";
    SimpleTypeKind["BOOLEAN"] = "BOOLEAN";
    SimpleTypeKind["BIG_INT"] = "BIG_INT";
    SimpleTypeKind["NULL"] = "NULL";
    SimpleTypeKind["UNDEFINED"] = "UNDEFINED";
    SimpleTypeKind["NEVER"] = "NEVER";
    SimpleTypeKind["ANY"] = "ANY";
    SimpleTypeKind["UNKNOWN"] = "UNKNOWN";
    SimpleTypeKind["VOID"] = "VOID";
    SimpleTypeKind["UNION"] = "UNION";
    SimpleTypeKind["ENUM"] = "ENUM";
    SimpleTypeKind["ENUM_MEMBER"] = "ENUM_MEMBER";
    SimpleTypeKind["INTERSECTION"] = "INTERSECTION";
    SimpleTypeKind["TUPLE"] = "TUPLE";
    SimpleTypeKind["INTERFACE"] = "INTERFACE";
    SimpleTypeKind["OBJECT"] = "OBJECT";
    SimpleTypeKind["FUNCTION"] = "FUNCTION";
    SimpleTypeKind["METHOD"] = "METHOD";
    SimpleTypeKind["CLASS"] = "CLASS";
    SimpleTypeKind["CIRCULAR_TYPE_REF"] = "CIRCULAR_TYPE_REF";
    SimpleTypeKind["GENERIC_ARGUMENTS"] = "GENERIC_ARGUMENTS";
    SimpleTypeKind["GENERIC_PARAMETER"] = "GENERIC_PARAMETER";
    SimpleTypeKind["ALIAS"] = "ALIAS";
    SimpleTypeKind["DATE"] = "DATE";
    SimpleTypeKind["ARRAY"] = "ARRAY";
    SimpleTypeKind["PROMISE"] = "PROMISE";
})(exports.SimpleTypeKind || (exports.SimpleTypeKind = {}));
(function (SimpleTypeModifierKind) {
    SimpleTypeModifierKind["EXPORT"] = "EXPORT";
    SimpleTypeModifierKind["AMBIENT"] = "AMBIENT";
    SimpleTypeModifierKind["PUBLIC"] = "PUBLIC";
    SimpleTypeModifierKind["PRIVATE"] = "PRIVATE";
    SimpleTypeModifierKind["PROTECTED"] = "PROTECTED";
    SimpleTypeModifierKind["STATIC"] = "STATIC";
    SimpleTypeModifierKind["READONLY"] = "READONLY";
    SimpleTypeModifierKind["ABSTRACT"] = "ABSTRACT";
    SimpleTypeModifierKind["ASYNC"] = "ASYNC";
    SimpleTypeModifierKind["DEFAULT"] = "DEFAULT";
})(exports.SimpleTypeModifierKind || (exports.SimpleTypeModifierKind = {}));
/* eslint-disable @typescript-eslint/no-explicit-any */
function isSimpleType(type) {
    return typeof type === "object" && "kind" in type && Object.values(exports.SimpleTypeKind).find((key) => key === type.kind) != null;
}
const LITERAL_TYPE_KINDS = [exports.SimpleTypeKind.STRING_LITERAL, exports.SimpleTypeKind.NUMBER_LITERAL, exports.SimpleTypeKind.BOOLEAN_LITERAL, exports.SimpleTypeKind.BIG_INT_LITERAL];
function isSimpleTypeLiteral(type) {
    return LITERAL_TYPE_KINDS.includes(type.kind);
}
const PRIMITIVE_TYPE_KINDS = [
    ...LITERAL_TYPE_KINDS,
    exports.SimpleTypeKind.STRING,
    exports.SimpleTypeKind.NUMBER,
    exports.SimpleTypeKind.BOOLEAN,
    exports.SimpleTypeKind.BIG_INT,
    exports.SimpleTypeKind.NULL,
    exports.SimpleTypeKind.UNDEFINED,
    exports.SimpleTypeKind.VOID
];
function isSimpleTypePrimitive(type) {
    return PRIMITIVE_TYPE_KINDS.includes(type.kind);
}
const PRIMITIVE_TYPE_TO_LITERAL_MAP = {
    [exports.SimpleTypeKind.STRING]: exports.SimpleTypeKind.STRING_LITERAL,
    [exports.SimpleTypeKind.NUMBER]: exports.SimpleTypeKind.NUMBER_LITERAL,
    [exports.SimpleTypeKind.BOOLEAN]: exports.SimpleTypeKind.BOOLEAN_LITERAL,
    [exports.SimpleTypeKind.BIG_INT]: exports.SimpleTypeKind.BIG_INT_LITERAL
};
const LITERAL_TYPE_TO_PRIMITIVE_TYPE_MAP = {
    [exports.SimpleTypeKind.STRING_LITERAL]: exports.SimpleTypeKind.STRING,
    [exports.SimpleTypeKind.NUMBER_LITERAL]: exports.SimpleTypeKind.NUMBER,
    [exports.SimpleTypeKind.BOOLEAN_LITERAL]: exports.SimpleTypeKind.BOOLEAN,
    [exports.SimpleTypeKind.BIG_INT_LITERAL]: exports.SimpleTypeKind.BIG_INT
};
const IMPLICIT_GENERIC = [exports.SimpleTypeKind.ARRAY, exports.SimpleTypeKind.TUPLE, exports.SimpleTypeKind.PROMISE];
function isImplicitGenericType(type) {
    return IMPLICIT_GENERIC.includes(type.kind);
}

/**
 * Returns a type that represents the length of the Tuple type
 * Read more here: https://github.com/microsoft/TypeScript/pull/24897
 * @param tuple
 */
function getTupleLengthType(tuple) {
    // When the tuple has rest argument, return "number"
    if (tuple.hasRestElement) {
        return {
            kind: exports.SimpleTypeKind.NUMBER
        };
    }
    // Else return an intersection of number literals that represents all possible lengths
    const minLength = tuple.members.filter(member => !member.optional).length;
    if (minLength === tuple.members.length) {
        return {
            kind: exports.SimpleTypeKind.NUMBER_LITERAL,
            value: minLength
        };
    }
    return {
        kind: exports.SimpleTypeKind.UNION,
        types: new Array(tuple.members.length - minLength + 1).fill(0).map((_, i) => ({
            kind: exports.SimpleTypeKind.NUMBER_LITERAL,
            value: minLength + i
        }))
    };
}
function simplifySimpleTypes(types) {
    let newTypes = [...types];
    const NULLABLE_TYPE_KINDS = [exports.SimpleTypeKind.UNDEFINED, exports.SimpleTypeKind.NULL];
    // Only include one instance of primitives and literals
    newTypes = newTypes.filter((type, i) => {
        // Only include one of each literal with specific value
        if (isSimpleTypeLiteral(type)) {
            return !newTypes.slice(0, i).some(newType => newType.kind === type.kind && newType.value === type.value);
        }
        if (PRIMITIVE_TYPE_KINDS.includes(type.kind) || NULLABLE_TYPE_KINDS.includes(type.kind)) {
            // Remove this type from the array if there is already a primitive in the array
            return !newTypes.slice(0, i).some(t => t.kind === type.kind);
        }
        return true;
    });
    // Simplify boolean literals
    const booleanLiteralTypes = newTypes.filter((t) => t.kind === exports.SimpleTypeKind.BOOLEAN_LITERAL);
    if (booleanLiteralTypes.find(t => t.value === true) != null && booleanLiteralTypes.find(t => t.value === false) != null) {
        newTypes = [...newTypes.filter(type => type.kind !== exports.SimpleTypeKind.BOOLEAN_LITERAL), { kind: exports.SimpleTypeKind.BOOLEAN }];
    }
    // Reorder "NULL" and "UNDEFINED" to be last
    const nullableTypes = newTypes.filter((t) => NULLABLE_TYPE_KINDS.includes(t.kind));
    if (nullableTypes.length > 0) {
        newTypes = [
            ...newTypes.filter(t => !NULLABLE_TYPE_KINDS.includes(t.kind)),
            ...nullableTypes.sort((t1, t2) => (t1.kind === exports.SimpleTypeKind.NULL ? (t2.kind === exports.SimpleTypeKind.UNDEFINED ? -1 : 0) : t2.kind === exports.SimpleTypeKind.NULL ? 1 : 0))
        ];
    }
    return newTypes;
}

const tsModule = { ts: tsModuleType };
function setTypescriptModule(newModule) {
    tsModule.ts = newModule;
}

function or(list, match) {
    return list.find((a, i) => match(a, i)) != null;
}
function and(list, match) {
    return list.find((a, i) => !match(a, i)) == null;
}

function isTypeChecker(obj) {
    return obj != null && typeof obj === "object" && "getSymbolAtLocation" in obj;
}
function isProgram(obj) {
    return obj != null && typeof obj === "object" && "getTypeChecker" in obj && "getCompilerOptions" in obj;
}
function isNode(obj) {
    return obj != null && typeof obj === "object" && "kind" in obj && "flags" in obj && "pos" in obj && "end" in obj;
}
function hasFlag(type, flag, op = "and") {
    if (Array.isArray(flag)) {
        return (op === "and" ? and : or)(flag, f => hasFlag(type, f));
    }
    return (type.flags & flag) !== 0;
}
function isBoolean(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.BooleanLike);
}
function isBooleanLiteral(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.BooleanLiteral);
}
function isBigIntLiteral(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.BigIntLiteral);
}
function isLiteral(type) {
    return type.isLiteral() || isBooleanLiteral(type) || isBigIntLiteral(type);
}
function isString(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.StringLike);
}
function isNumber(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.NumberLike);
}
function isEnum(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.EnumLike);
}
function isBigInt(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.BigIntLike) || (type.symbol && type.symbol.getName() === "BigInt");
}
function isObject(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.Object);
}
function isUnknown(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.Unknown);
}
function isNull(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.Null);
}
function isUndefined(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.Undefined);
}
function isVoid(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.VoidLike);
}
function isNever(type) {
    return hasFlag(type, tsModule.ts.TypeFlags.Never);
}
function isObjectTypeReference(type) {
    return (type.objectFlags & tsModule.ts.ObjectFlags.Reference) !== 0;
}
function isMethod(type) {
    if (!isObject(type))
        return false;
    const symbol = type.getSymbol();
    if (symbol == null)
        return false;
    const decl = getDeclaration(symbol);
    if (decl == null)
        return false;
    return tsModule.ts.isMethodDeclaration(decl);
}
function getDeclaration(symbol) {
    const declarations = symbol.getDeclarations();
    if (declarations == null || declarations.length === 0)
        return symbol.valueDeclaration;
    return declarations[0];
}
function isArray(type, checker) {
    if (!isObject(type))
        return false;
    const symbol = type.getSymbol();
    if (symbol == null)
        return false;
    return getTypeArguments(type, checker).length === 1 && ["ArrayLike", "ReadonlyArray", "Array"].includes(symbol.getName());
    //return symbol.getName() === "Array"; // && getTypeArguments(type).length === 1;
}
function isPromise(type, checker) {
    if (!isObject(type))
        return false;
    const symbol = type.getSymbol();
    if (symbol == null)
        return false;
    return getTypeArguments(type, checker).length === 1 && ["PromiseLike", "Promise"].includes(symbol.getName());
}
function isDate(type) {
    if (!isObject(type))
        return false;
    const symbol = type.getSymbol();
    if (symbol == null)
        return false;
    return symbol.getName() === "Date";
}
function isTupleTypeReference(type) {
    const target = getTargetType(type);
    if (target == null)
        return false;
    return (target.objectFlags & tsModule.ts.ObjectFlags.Tuple) !== 0;
}
function isFunction(type) {
    if (!isObject(type))
        return false;
    const symbol = type.getSymbol();
    if (symbol == null)
        return false;
    return (symbol.flags & tsModule.ts.SymbolFlags.Function) !== 0 || symbol.escapedName === "Function" || (symbol.members != null && symbol.members.has("__call"));
}
function getTypeArguments(type, checker) {
    if (isObject(type)) {
        if (isObjectTypeReference(type)) {
            if ("getTypeArguments" in checker) {
                return Array.from(checker.getTypeArguments(type) || []);
            }
            else {
                return Array.from(type.typeArguments || []);
            }
        }
    }
    return [];
}
function getTargetType(type) {
    if (isObject(type) && isObjectTypeReference(type)) {
        return type.target;
    }
}
function getModifiersFromDeclaration(declaration) {
    const tsModifiers = tsModule.ts.getCombinedModifierFlags(declaration);
    const modifiers = [];
    const map = {
        [tsModule.ts.ModifierFlags.Export]: exports.SimpleTypeModifierKind.EXPORT,
        [tsModule.ts.ModifierFlags.Ambient]: exports.SimpleTypeModifierKind.AMBIENT,
        [tsModule.ts.ModifierFlags.Public]: exports.SimpleTypeModifierKind.PUBLIC,
        [tsModule.ts.ModifierFlags.Private]: exports.SimpleTypeModifierKind.PRIVATE,
        [tsModule.ts.ModifierFlags.Protected]: exports.SimpleTypeModifierKind.PROTECTED,
        [tsModule.ts.ModifierFlags.Static]: exports.SimpleTypeModifierKind.STATIC,
        [tsModule.ts.ModifierFlags.Readonly]: exports.SimpleTypeModifierKind.READONLY,
        [tsModule.ts.ModifierFlags.Abstract]: exports.SimpleTypeModifierKind.ABSTRACT,
        [tsModule.ts.ModifierFlags.Async]: exports.SimpleTypeModifierKind.ASYNC,
        [tsModule.ts.ModifierFlags.Default]: exports.SimpleTypeModifierKind.DEFAULT
    };
    Object.entries(map).forEach(([tsModifier, modifierKind]) => {
        if ((tsModifiers & Number(tsModifier)) !== 0) {
            modifiers.push(modifierKind);
        }
    });
    return modifiers;
}

function toSimpleType(type, checker, cache) {
    if (isNode(type)) {
        // "type" is a "Node", convert it to a "Type" and continue.
        return toSimpleType(checker.getTypeAtLocation(type), checker);
    }
    return toSimpleTypeInternalCaching(type, {
        checker,
        circularCache: new WeakMap(),
        cache: cache || new WeakMap()
    });
}
function toSimpleTypeInternalCaching(type, options) {
    const placeholder = {};
    // Cache the result of the conversion to a SimpleType if the type doesn't refer to an alias and is not a type parameter.
    // Here we make sure that all SimpleTypes refer to the same instance.
    if (!options.cache.has(type)) {
        if (type.aliasSymbol == null && type.aliasTypeArguments == null && !type.isTypeParameter() && !(isObject(type) && isObjectTypeReference(type))) {
            options.cache.set(type, placeholder);
        }
    }
    else {
        return options.cache.get(type);
    }
    if (options.circularCache.has(type)) {
        return {
            kind: exports.SimpleTypeKind.CIRCULAR_TYPE_REF,
            ref: options.circularCache.get(type)
        };
    }
    else {
        // Connect the type to the placeholder reference
        // Circular types will point to this reference
        // Only return a circular ref if it's a class of interface.
        // Don't return circular ref if it's a primitive like a "number"
        if (type.isClassOrInterface() || (isObject(type) && isObjectTypeReference(type))) {
            options.circularCache.set(type, placeholder);
        }
    }
    // Construct the simple type recursively
    const simpleTypeOverwrite = toSimpleTypeInternal(type, options);
    // Strip undefined keys to make the output cleaner
    Object.entries(simpleTypeOverwrite).forEach(([k, v]) => {
        if (v == null)
            delete simpleTypeOverwrite[k];
    });
    // Transfer properties on the simpleType to the placeholder
    // This makes it possible to keep on using the reference "placeholder".
    Object.assign(placeholder, simpleTypeOverwrite);
    // Try to lift a potential generic type and wrap the result in a "GENERIC_ARGUMENTS" simple type and/or "ALIAS" type.
    return liftGenericType(placeholder, type, options);
}
/**
 * Tries to lift a potential generic type and wrap the result in a "GENERIC_ARGUMENTS" simple type and/or "ALIAS" type.
 * Returns the "simpleType" otherwise.
 * @param simpleType
 * @param type
 * @param options
 */
function liftGenericType(simpleType, type, options) {
    // Check for alias reference
    if (type.aliasSymbol != null) {
        const aliasDeclaration = getDeclaration(type.aliasSymbol);
        const typeParameters = getTypeParameters(aliasDeclaration, options);
        // Lift the simple type to an ALIAS type.
        const aliasType = {
            kind: exports.SimpleTypeKind.ALIAS,
            name: type.aliasSymbol.getName(),
            target: simpleType,
            typeParameters
        };
        // Lift the alias type if it uses generic arguments.
        if (type.aliasTypeArguments != null) {
            const typeArguments = Array.from(type.aliasTypeArguments || []).map(t => toSimpleTypeInternalCaching(t, options));
            return {
                kind: exports.SimpleTypeKind.GENERIC_ARGUMENTS,
                target: aliasType,
                typeArguments
            };
        }
        return aliasType;
    }
    // Check if the type is a generic interface/class reference and lift it.
    else if (isObject(type) && isObjectTypeReference(type) && type.typeArguments != null && type.typeArguments.length > 0) {
        // Special case for array, tuple and promise, they are generic in themselves
        if (isImplicitGenericType(simpleType)) {
            return simpleType;
        }
        const typeArguments = Array.from(type.typeArguments || []).map(t => toSimpleTypeInternalCaching(t, options));
        return {
            kind: exports.SimpleTypeKind.GENERIC_ARGUMENTS,
            target: simpleType,
            typeArguments
        };
    }
    return simpleType;
}
function toSimpleTypeInternal(type, options) {
    const { checker } = options;
    const symbol = type.getSymbol();
    const name = symbol != null ? getRealSymbolName(symbol) : undefined;
    if (isLiteral(type)) {
        const literalSimpleType = literalToSimpleType(type, checker);
        if (literalSimpleType != null) {
            // Enum members
            if (symbol != null && symbol.flags & tsModule.ts.SymbolFlags.EnumMember) {
                const parentSymbol = symbol.parent;
                if (parentSymbol != null) {
                    return {
                        name: name || "",
                        fullName: `${parentSymbol.name}.${name}`,
                        kind: exports.SimpleTypeKind.ENUM_MEMBER,
                        type: literalSimpleType
                    };
                }
            }
            // Literals types
            return literalSimpleType;
        }
    }
    // Primitive types
    else if (isString(type)) {
        return { kind: exports.SimpleTypeKind.STRING, name };
    }
    else if (isNumber(type)) {
        return { kind: exports.SimpleTypeKind.NUMBER, name };
    }
    else if (isBoolean(type)) {
        return { kind: exports.SimpleTypeKind.BOOLEAN, name };
    }
    else if (isBigInt(type)) {
        return { kind: exports.SimpleTypeKind.BIG_INT, name };
    }
    else if (isUndefined(type)) {
        return { kind: exports.SimpleTypeKind.UNDEFINED, name };
    }
    else if (isNull(type)) {
        return { kind: exports.SimpleTypeKind.NULL, name };
    }
    else if (isUnknown(type)) {
        return { kind: exports.SimpleTypeKind.UNKNOWN, name };
    }
    else if (isVoid(type)) {
        return { kind: exports.SimpleTypeKind.VOID, name };
    }
    else if (isNever(type)) {
        return { kind: exports.SimpleTypeKind.NEVER, name };
    }
    // Enum
    else if (isEnum(type) && type.isUnion()) {
        return {
            name: name || "",
            kind: exports.SimpleTypeKind.ENUM,
            types: type.types.map(t => toSimpleTypeInternalCaching(t, options))
        };
    }
    // Promise
    else if (isPromise(type, checker)) {
        return {
            kind: exports.SimpleTypeKind.PROMISE,
            name,
            type: toSimpleTypeInternalCaching(getTypeArguments(type, checker)[0], options)
        };
    }
    // Unions and intersections
    else if (type.isUnion()) {
        return {
            kind: exports.SimpleTypeKind.UNION,
            types: simplifySimpleTypes(type.types.map(t => toSimpleTypeInternalCaching(t, options))),
            name
        };
    }
    else if (type.isIntersection()) {
        return {
            kind: exports.SimpleTypeKind.INTERSECTION,
            types: simplifySimpleTypes(type.types.map(t => toSimpleTypeInternalCaching(t, options))),
            name
        };
    }
    // Date
    else if (isDate(type)) {
        return {
            kind: exports.SimpleTypeKind.DATE,
            name
        };
    }
    // Array
    else if (isArray(type, checker)) {
        return {
            kind: exports.SimpleTypeKind.ARRAY,
            type: toSimpleTypeInternalCaching(getTypeArguments(type, checker)[0], options),
            name
        };
    }
    else if (isTupleTypeReference(type)) {
        const types = getTypeArguments(type, checker);
        const minLength = type.target.minLength;
        return {
            kind: exports.SimpleTypeKind.TUPLE,
            hasRestElement: type.target.hasRestElement || false,
            members: types.map((childType, i) => {
                return {
                    optional: i >= minLength,
                    type: toSimpleTypeInternalCaching(childType, options)
                };
            }),
            name
        };
    }
    // Function
    else if (symbol != null && (isFunction(type) || isMethod(type))) {
        const functionDeclaration = getDeclaration(symbol);
        if (functionDeclaration != null) {
            const simpleType = getSimpleFunctionFromDeclaration(functionDeclaration, options);
            if (simpleType != null) {
                simpleType.name = simpleType.name || name;
            }
            if (simpleType != null) {
                return simpleType;
            }
            return {
                kind: exports.SimpleTypeKind.FUNCTION,
                name
            };
        }
    }
    // Alternative way of getting functions
    else if (isObject(type) && type.getCallSignatures().length > 0) {
        const functionDeclaration = type.getCallSignatures()[0].getDeclaration();
        const simpleType = getSimpleFunctionFromDeclaration(functionDeclaration, options);
        if (simpleType != null) {
            return simpleType;
        }
    }
    // Class
    else if (type.isClass() && symbol != null) {
        const classDecl = getDeclaration(symbol);
        if (classDecl != null && tsModule.ts.isClassDeclaration(classDecl)) {
            const ctor = (() => {
                const ctorSymbol = symbol != null && symbol.members != null ? symbol.members.get("__constructor") : undefined;
                if (ctorSymbol != null && symbol != null) {
                    const ctorDecl = ctorSymbol.declarations.length > 0 ? ctorSymbol.declarations[0] : ctorSymbol.valueDeclaration;
                    if (ctorDecl != null && tsModule.ts.isConstructorDeclaration(ctorDecl)) {
                        return getSimpleFunctionFromDeclaration(ctorDecl, options);
                    }
                }
            })();
            const members = checker
                .getPropertiesOfType(type)
                .map(symbol => {
                const declaration = getDeclaration(symbol);
                // Some instance properties may have an undefined declaration.
                // Since we can't do too much without a declaration, filtering
                // these out seems like the best strategy for the moment.
                //
                // See https://github.com/runem/web-component-analyzer/issues/60 for
                // more info.
                if (declaration == null)
                    return null;
                return {
                    name: symbol.name,
                    modifiers: getModifiersFromDeclaration(declaration),
                    type: toSimpleTypeInternalCaching(checker.getTypeAtLocation(declaration), options)
                };
            })
                .filter((member) => member != null);
            const typeParameters = getTypeParameters(getDeclaration(symbol), options);
            return {
                kind: exports.SimpleTypeKind.CLASS,
                name,
                ctor,
                typeParameters,
                properties: members.filter(m => m.type.kind !== exports.SimpleTypeKind.METHOD),
                methods: members.filter(m => m.type.kind === exports.SimpleTypeKind.METHOD)
            };
        }
    }
    // Interface
    else if (type.isClassOrInterface() || isObject(type)) {
        const members = checker.getPropertiesOfType(type).map(symbol => ({
            name: symbol.name,
            optional: (symbol.flags & tsModule.ts.SymbolFlags.Optional) !== 0,
            type: toSimpleTypeInternalCaching(checker.getTypeAtLocation(symbol.valueDeclaration), options)
        }));
        const typeParameters = (isObjectTypeReference(type) && type.target.typeParameters ? type.target.typeParameters.map(t => toSimpleTypeInternalCaching(t, options)) : undefined) ||
            (symbol != null ? getTypeParameters(getDeclaration(symbol), options) : undefined);
        return {
            kind: type.isClassOrInterface() ? exports.SimpleTypeKind.INTERFACE : exports.SimpleTypeKind.OBJECT,
            typeParameters,
            members,
            name
        };
    }
    if (type.isTypeParameter() && symbol != null) {
        const defaultType = type.getDefault();
        const defaultSimpleType = defaultType != null ? toSimpleTypeInternalCaching(defaultType, options) : undefined;
        return {
            kind: exports.SimpleTypeKind.GENERIC_PARAMETER,
            name: symbol.getName(),
            default: defaultSimpleType
        };
    }
    return {
        kind: exports.SimpleTypeKind.ANY,
        name
    };
}
function literalToSimpleType(type, checker) {
    if (type.isNumberLiteral()) {
        return {
            kind: exports.SimpleTypeKind.NUMBER_LITERAL,
            value: type.value
        };
    }
    else if (type.isStringLiteral()) {
        return {
            kind: exports.SimpleTypeKind.STRING_LITERAL,
            value: type.value
        };
    }
    else if (isBooleanLiteral(type)) {
        // See https://github.com/Microsoft/TypeScript/issues/22269 for more information
        return {
            kind: exports.SimpleTypeKind.BOOLEAN_LITERAL,
            value: checker.typeToString(type) === "true"
        };
    }
    else if (isBigIntLiteral(type)) {
        return {
            kind: exports.SimpleTypeKind.BIG_INT_LITERAL,
            /* global BigInt */
            value: BigInt(`${type.value.negative ? "-" : ""}${type.value.base10Value}`)
        };
    }
}
function getSimpleFunctionFromDeclaration(functionDeclaration, options, checkReturnType) {
    const { checker } = options;
    const symbol = checker.getSymbolAtLocation(functionDeclaration);
    const type = checker.getTypeAtLocation(functionDeclaration);
    if (tsModule.ts.isFunctionLike(functionDeclaration)) {
        const signature = checker.getSignatureFromDeclaration(functionDeclaration);
        if (signature != null) {
            const argTypes = functionDeclaration.parameters.map(parameterDecl => {
                const argType = checker.getTypeAtLocation(parameterDecl);
                return {
                    name: parameterDecl.name.getText(),
                    optional: parameterDecl.questionToken != null,
                    type: toSimpleTypeInternalCaching(argType, options),
                    spread: parameterDecl.dotDotDotToken != null,
                    initializer: parameterDecl.initializer != null
                };
            });
            const name = symbol != null ? symbol.getName() : undefined;
            const kind = isMethod(type) ? exports.SimpleTypeKind.METHOD : exports.SimpleTypeKind.FUNCTION;
            const returnType = toSimpleTypeInternalCaching(checker.getReturnTypeOfSignature(signature), options);
            const typeParameters = getTypeParameters(functionDeclaration, options);
            return { name, kind, returnType, argTypes, typeParameters };
        }
    }
}
const BLACKLISTED_SYMBOL_NAMES = ["__type", "__object", "__function"];
function getRealSymbolName(symbol) {
    const name = symbol.getName();
    if (name != null && BLACKLISTED_SYMBOL_NAMES.includes(name)) {
        return undefined;
    }
    return name;
}
function getTypeParameters(declaration, options) {
    if (declaration == null)
        return undefined;
    if (tsModule.ts.isClassDeclaration(declaration) ||
        tsModule.ts.isFunctionDeclaration(declaration) ||
        tsModule.ts.isFunctionTypeNode(declaration) ||
        tsModule.ts.isTypeAliasDeclaration(declaration) ||
        tsModule.ts.isMethodDeclaration(declaration) ||
        tsModule.ts.isMethodSignature(declaration)) {
        return declaration.typeParameters == null
            ? undefined
            : Array.from(declaration.typeParameters)
                .map(td => options.checker.getTypeAtLocation(td))
                .map(t => toSimpleTypeInternalCaching(t, options));
    }
    return undefined;
}

function isAssignableToSimpleTypeKind(type, kind, optionsOrChecker, options = {}) {
    if (!isSimpleType(type)) {
        return isAssignableToSimpleTypeKind(toSimpleType(type, optionsOrChecker), kind, options);
    }
    options = (isTypeChecker(optionsOrChecker) ? options : optionsOrChecker) || {};
    // Make sure that an object without members are treated as ANY
    switch (type.kind) {
        case exports.SimpleTypeKind.OBJECT:
            if (type.members == null || type.members.length === 0) {
                return isAssignableToSimpleTypeKind({ kind: exports.SimpleTypeKind.ANY }, kind, options);
            }
            break;
        case exports.SimpleTypeKind.ANY:
            if (options.matchAny) {
                return true;
            }
            break;
    }
    switch (type.kind) {
        case exports.SimpleTypeKind.ENUM:
        case exports.SimpleTypeKind.UNION:
            return or(type.types, childType => isAssignableToSimpleTypeKind(childType, kind, options));
        case exports.SimpleTypeKind.INTERSECTION:
            return and(type.types, childType => isAssignableToSimpleTypeKind(childType, kind, options));
        case exports.SimpleTypeKind.ENUM_MEMBER:
            return isAssignableToSimpleTypeKind(type.type, kind, options);
        case exports.SimpleTypeKind.ALIAS:
            return isAssignableToSimpleTypeKind(type.target, kind, options);
        case exports.SimpleTypeKind.GENERIC_PARAMETER:
            return isAssignableToSimpleTypeKind(type.default || { kind: exports.SimpleTypeKind.ANY }, kind, options);
        default:
            if (Array.isArray(kind)) {
                return (options.op === "or" ? or : and)(kind, itemKind => type.kind === itemKind);
            }
            return type.kind === kind;
    }
}

function isAssignableToPrimitiveType(type, checker) {
    if (isSimpleType(type)) {
        return isAssignableToSimpleTypeKind(type, PRIMITIVE_TYPE_KINDS, { op: "or", matchAny: true });
    }
    return isAssignableToSimpleTypeKind(type, PRIMITIVE_TYPE_KINDS, checker, { op: "or", matchAny: true });
}

/**
 * Combines multiple intersecting types into one single type.
 * This function can return an INTERSECTION type again if the types doesn't overlap.
 * @param types
 */
function combineIntersectingSimpleTypes(types) {
    const combined = new Map();
    let members = [];
    for (const type of types) {
        if (isSimpleTypeLiteral(type)) {
            const mappedPrimitive = LITERAL_TYPE_TO_PRIMITIVE_TYPE_MAP[type.kind];
            // 2 & number ---> number
            if (combined.has(mappedPrimitive)) {
                // Do nothing if the non-literal primitive is already in the map
                continue;
            }
            // 2 & string ---> never
            if (PRIMITIVE_TYPE_KINDS.some(primitiveType => primitiveType != mappedPrimitive && combined.has(primitiveType))) {
                combined.set(exports.SimpleTypeKind.NEVER, { kind: exports.SimpleTypeKind.NEVER });
            }
            // 2 & 3 ---> never
            if (members.some(member => member.kind === type.kind && member.value !== type.value)) {
                combined.set(exports.SimpleTypeKind.NEVER, { kind: exports.SimpleTypeKind.NEVER });
            }
            // Always push type literals to "members"
            members.push(type);
        }
        else if (isSimpleTypePrimitive(type)) {
            combined.set(type.kind, type);
            // A non-literal primitive always trumps a literal type.
            // Therefore, remove the literal from "members"
            members = members.filter(member => member.kind === LITERAL_TYPE_TO_PRIMITIVE_TYPE_MAP[type.kind]);
        }
        else {
            switch (type.kind) {
                // Combine classes
                case exports.SimpleTypeKind.CLASS:
                    setExistingOrCombine(combined, exports.SimpleTypeKind.INTERFACE, type, (existing) => ({
                        kind: exports.SimpleTypeKind.INTERFACE,
                        members: combineNamedMembers([...type.properties, ...type.methods, ...(existing.members || [])])
                    }));
                    break;
                // Combine objects and interfaces
                case exports.SimpleTypeKind.OBJECT:
                case exports.SimpleTypeKind.INTERFACE:
                    setExistingOrCombine(combined, exports.SimpleTypeKind.INTERFACE, type, (existing) => ({
                        kind: exports.SimpleTypeKind.INTERFACE,
                        members: combineNamedMembers([...(type.members || []), ...(existing.members || [])])
                    }));
                    break;
                // Combine arrays
                case exports.SimpleTypeKind.ARRAY:
                    setExistingOrCombine(combined, exports.SimpleTypeKind.ARRAY, type, (existing) => ({
                        kind: exports.SimpleTypeKind.ARRAY,
                        type: combineIntersectingSimpleTypes([type.type, existing.type])
                    }));
                    break;
                // Combine tuples
                case exports.SimpleTypeKind.TUPLE:
                    members.push(type);
                    break;
                default:
                    members.push(type);
                    break;
            }
        }
    }
    // If all types were combined into one, return this one
    if (combined.has(exports.SimpleTypeKind.NEVER) || combined.size === 0) {
        return {
            kind: exports.SimpleTypeKind.INTERSECTION,
            types
        };
    }
    const combinedTypes = Array.from(combined.values());
    if (combinedTypes.length === 1) {
        return combinedTypes[0];
    }
    // If we still have multiple choices types, return an intersection
    return {
        kind: exports.SimpleTypeKind.INTERSECTION,
        types: combinedTypes
    };
}
/**
 * Zips two lists with a combine callback
 * @param listA
 * @param listB
 * @param combine
 */
/*function zipCombine<T, U>(listA: T[], listB: U[], combine: (a: T, b: U) => T | U): (T | U)[] {
 return new Array(Math.max(listA.length, listB.length)).fill({} as any).map((_, i) => combine(listA[i], listB[i]));
 }*/
/**
 * Sets a key in a map to "alternative" if there is not already an existing key set.
 * If there is already an existing key set, the "combine" callback is called with the value.
 * @param map
 * @param key
 * @param alternative
 * @param combine
 */
function setExistingOrCombine(map, key, alternative, combine) {
    const existing = map.get(key);
    map.set(key, existing == null ? alternative : combine(existing));
    return map;
}
/**
 * Combines multiple named members and their types.
 * @param members
 */
function combineNamedMembers(members) {
    return Array.from(members
        .reduce((map, member) => setExistingOrCombine(map, member.name, member, existingMember => ({
        name: member.name,
        optional: member.optional && existingMember.optional,
        type: combineIntersectingSimpleTypes([member.type, existingMember.type])
    })), new Map())
        .values());
}

const DEFAULT_CONFIG = {
    strict: true
};
/**
 * Returns if typeB is assignable to typeA.
 * @param typeA Type A
 * @param typeB Type B
 * @param config
 */
function isAssignableToSimpleType(typeA, typeB, config = DEFAULT_CONFIG) {
    return isAssignableToSimpleTypeInternal(typeA, typeB, {
        config,
        insideType: new Set(),
        comparingTypes: new Map(),
        genericParameterMapA: new Map(),
        genericParameterMapB: new Map()
    });
}
function isAssignableToSimpleTypeInternal(typeA, typeB, options) {
    /**
    options = { ...options };
    (options as any).depth = ((options as any).depth || 0) + 1;
    if ((options as any).depth > 200) {
        return true;
    }
    if ((options as any).depth > 150) {
        //console.log("###", "\t".repeat((options as any).depth), simpleTypeToString(typeA), "===", simpleTypeToString(typeB), "(", typeA.kind, "===", typeB.kind, ")", (options as any).depth, "###");
        //if ((options as any).depth > 10) return false;
        console.log(
            "###",
            "\t".repeat((options as any).depth),
            require("./simple-type-to-string").simpleTypeToString(typeA),
            "===",
            require("./simple-type-to-string").simpleTypeToString(typeB),
            "(",
            typeA.kind,
            "===",
            typeB.kind,
            ")",
            (options as any).depth,
            "###"
        );
    }
    /**/
    // Make it possible to overwrite default behavior by running user defined logic for comparing types
    if (options.config.isAssignable != null) {
        const result = options.config.isAssignable(typeA, typeB, options.config);
        if (result != null) {
            return result;
        }
    }
    if (typeA === typeB) {
        return true;
    }
    // When comparing types S and T, the relationship in question is assumed to be true
    //   for every directly or indirectly nested occurrence of the same S and the same T
    if (options.comparingTypes.has(typeA)) {
        if (options.comparingTypes.get(typeA).has(typeB)) {
            return true;
        }
    }
    // We might need a better way of handling refs, but these check are good for now
    if (options.insideType.has(typeA) || options.insideType.has(typeB)) {
        return true;
    }
    // Any and unknown
    if (typeA.kind === exports.SimpleTypeKind.UNKNOWN || typeA.kind === exports.SimpleTypeKind.ANY) {
        return true;
    }
    // This check has been added to optimize complex types.
    // It's only run on named non-generic interface, object, alias and class types
    // Here we compare their names to see if they are equal. For example comparing "HTMLElement === HTMLElement" don't need to traverse both structures.
    // I will remove this check after I add optimization and caching of comparison results (especially for built in types)
    // The basic challenge is that types that I compare do not necessarily share references, so a reference check isn't enough
    if (typeA.kind === typeB.kind &&
        [exports.SimpleTypeKind.INTERFACE, exports.SimpleTypeKind.OBJECT, exports.SimpleTypeKind.ALIAS, exports.SimpleTypeKind.CLASS].includes(typeA.kind) &&
        !("typeParameters" in typeA) &&
        !("typeParameters" in typeB) &&
        (typeA.name && typeB.name && typeA.name === typeB.name)) {
        return true;
    }
    // Mutate options and add this comparison to "comparingTypes".
    // Only do this if one of the types is not a primitive to save memory.
    if (!isSimpleTypePrimitive(typeA) || !isSimpleTypePrimitive(typeB)) {
        options = { ...options };
        options.comparingTypes = new Map(options.comparingTypes);
        if (options.comparingTypes.has(typeA)) {
            options.comparingTypes.get(typeA).add(typeB);
        }
        else {
            options.comparingTypes.set(typeA, new Set([typeB]));
        }
    }
    switch (typeB.kind) {
        case exports.SimpleTypeKind.ANY:
            // "any" can be assigned to anything but "never"
            return typeA.kind !== exports.SimpleTypeKind.NEVER;
        case exports.SimpleTypeKind.NEVER:
            // "never" can be assigned to anything
            return true;
        case exports.SimpleTypeKind.CIRCULAR_TYPE_REF:
            return true;
        case exports.SimpleTypeKind.ENUM_MEMBER:
            return isAssignableToSimpleTypeInternal(typeA, typeB.type, options);
        case exports.SimpleTypeKind.ENUM:
            return and(typeB.types, childTypeB => isAssignableToSimpleTypeInternal(typeA, childTypeB, options));
        case exports.SimpleTypeKind.UNION:
            return and(typeB.types, childTypeB => isAssignableToSimpleTypeInternal(typeA, childTypeB, options));
        case exports.SimpleTypeKind.INTERSECTION: {
            // If we compare an intersection against an intersection, we need to compare from typeA and not typeB
            // Example: [string, number] & [string] === [string, number] & [string]
            if (typeA.kind === exports.SimpleTypeKind.INTERSECTION) {
                break;
            }
            const combinedIntersectionType = combineIntersectingSimpleTypes(typeB.types);
            if (combinedIntersectionType.kind === exports.SimpleTypeKind.INTERSECTION) {
                return or(combinedIntersectionType.types, memberB => isAssignableToSimpleTypeInternal(typeA, memberB, options));
            }
            return isAssignableToSimpleTypeInternal(typeA, combinedIntersectionType, options);
        }
        case exports.SimpleTypeKind.ALIAS:
            return isAssignableToSimpleTypeInternal(typeA, typeB.target, options);
        case exports.SimpleTypeKind.GENERIC_ARGUMENTS: {
            return isAssignableToSimpleTypeInternal(typeA, typeB.target, {
                ...options,
                genericParameterMapB: extendTypeParameterMap(typeB, options.genericParameterMapB)
            });
        }
        case exports.SimpleTypeKind.GENERIC_PARAMETER: {
            const newOptions = {
                ...options,
                insideType: new Set([...options.insideType, typeB])
            };
            const realType = options.genericParameterMapB.get(typeB.name);
            return isAssignableToSimpleTypeInternal(typeA, realType || typeB.default || { kind: exports.SimpleTypeKind.ANY }, newOptions);
        }
        case exports.SimpleTypeKind.UNDEFINED:
        case exports.SimpleTypeKind.NULL: {
            // When strict null checks are turned off, "undefined" and "null" are in the domain of every type but never
            const strictNullChecks = options.config.strictNullChecks === true || (options.config.strictNullChecks == null && options.config.strict);
            if (!strictNullChecks) {
                return typeA.kind !== exports.SimpleTypeKind.NEVER;
            }
            break;
        }
    }
    switch (typeA.kind) {
        // Circular references
        case exports.SimpleTypeKind.CIRCULAR_TYPE_REF:
            return true;
        // Literals and enum members
        case exports.SimpleTypeKind.NUMBER_LITERAL:
        case exports.SimpleTypeKind.STRING_LITERAL:
        case exports.SimpleTypeKind.BIG_INT_LITERAL:
        case exports.SimpleTypeKind.BOOLEAN_LITERAL:
            return isSimpleTypeLiteral(typeB) ? typeA.value === typeB.value : false;
        case exports.SimpleTypeKind.ENUM_MEMBER:
            // You can always assign a "number" | "number literal" to a "number literal" enum member type.
            if (typeA.type.kind === exports.SimpleTypeKind.NUMBER_LITERAL && [exports.SimpleTypeKind.NUMBER, exports.SimpleTypeKind.NUMBER_LITERAL].includes(typeB.kind)) {
                return true;
            }
            return isAssignableToSimpleTypeInternal(typeA.type, typeB, options);
        // Primitive types
        case exports.SimpleTypeKind.STRING:
        case exports.SimpleTypeKind.BOOLEAN:
        case exports.SimpleTypeKind.NUMBER:
        case exports.SimpleTypeKind.BIG_INT: {
            if (isSimpleTypeLiteral(typeB)) {
                return PRIMITIVE_TYPE_TO_LITERAL_MAP[typeA.kind] === typeB.kind;
            }
            return typeA.kind === typeB.kind;
        }
        case exports.SimpleTypeKind.UNDEFINED:
        case exports.SimpleTypeKind.NULL:
            return typeA.kind === typeB.kind;
        // Void
        case exports.SimpleTypeKind.VOID:
            return typeB.kind === exports.SimpleTypeKind.VOID || typeB.kind === exports.SimpleTypeKind.UNDEFINED;
        // Never
        case exports.SimpleTypeKind.NEVER:
            return false;
        // Alias
        case exports.SimpleTypeKind.ALIAS:
            return isAssignableToSimpleTypeInternal(typeA.target, typeB, options);
        // Generic types
        case exports.SimpleTypeKind.GENERIC_PARAMETER: {
            const newOptions = {
                ...options,
                insideType: new Set([...options.insideType, typeA])
            };
            const realType = options.genericParameterMapA.get(typeA.name);
            return isAssignableToSimpleTypeInternal(realType || typeA.default || { kind: exports.SimpleTypeKind.ANY }, typeB, newOptions);
        }
        case exports.SimpleTypeKind.GENERIC_ARGUMENTS:
            return isAssignableToSimpleTypeInternal(typeA.target, typeB, {
                ...options,
                genericParameterMapA: extendTypeParameterMap(typeA, options.genericParameterMapA)
            });
        // Arrays
        case exports.SimpleTypeKind.ARRAY: {
            if (typeB.kind === exports.SimpleTypeKind.ARRAY) {
                return isAssignableToSimpleTypeInternal(typeA.type, typeB.type, options);
            }
            else if (typeB.kind === exports.SimpleTypeKind.TUPLE) {
                return and(typeB.members, memberB => isAssignableToSimpleTypeInternal(typeA.type, memberB.type, options));
            }
            return false;
        }
        // Functions
        case exports.SimpleTypeKind.FUNCTION:
        case exports.SimpleTypeKind.METHOD: {
            if (typeB.kind !== exports.SimpleTypeKind.FUNCTION && typeB.kind !== exports.SimpleTypeKind.METHOD)
                return false;
            if (typeB.argTypes == null || typeB.returnType == null)
                return typeA.argTypes == null || typeA.returnType == null;
            if (typeA.argTypes == null || typeA.returnType == null)
                return true;
            // Any returntype is assignable to void
            if (typeA.returnType.kind !== exports.SimpleTypeKind.VOID && !isAssignableToSimpleTypeInternal(typeA.returnType, typeB.returnType, options))
                return false;
            // Test "this" types
            const typeAThisArg = typeA.argTypes.find(arg => arg.name === "this");
            const typeBThisArg = typeB.argTypes.find(arg => arg.name === "this");
            if (typeAThisArg != null && typeBThisArg != null) {
                if (!isAssignableToSimpleTypeInternal(typeAThisArg.type, typeBThisArg.type, options)) {
                    return false;
                }
            }
            const argTypesA = typeAThisArg == null ? typeA.argTypes : typeA.argTypes.filter(arg => arg !== typeAThisArg);
            const argTypesB = typeBThisArg == null ? typeB.argTypes : typeB.argTypes.filter(arg => arg !== typeBThisArg);
            // A function with 0 args can be assigned to any other function
            if (argTypesB.length === 0) {
                return true;
            }
            // Compare the types of each arg
            for (let i = 0; i < Math.max(argTypesA.length, argTypesB.length); i++) {
                const argA = argTypesA[i];
                const argB = argTypesB[i];
                // If argA is not present, check if argB is optional or not present as well
                if (argA == null) {
                    return argB == null || argB.optional;
                }
                // If argB is not present, check if argA is optional
                if (argB == null) {
                    return argA.optional;
                }
                // Check if we are comparing a spread against a non-spread
                if (argA.spread && argA.type.kind === exports.SimpleTypeKind.ARRAY && (!argB.spread && argB.type.kind !== exports.SimpleTypeKind.ARRAY)) {
                    if (!isAssignableToSimpleTypeInternal(argA.type.type, argB.type, options)) {
                        return false;
                    }
                    continue;
                }
                // If the types are not assignable return false right away
                if (!isAssignableToSimpleTypeInternal(argB.type, argA.type, options)) {
                    return false;
                }
            }
            return true;
        }
        // Unions and enum members
        case exports.SimpleTypeKind.ENUM:
        case exports.SimpleTypeKind.UNION:
            return or(typeA.types, childTypeA => isAssignableToSimpleTypeInternal(childTypeA, typeB, options));
        // Intersections
        case exports.SimpleTypeKind.INTERSECTION: {
            const combinedIntersectionType = combineIntersectingSimpleTypes(typeA.types);
            if (combinedIntersectionType.kind === exports.SimpleTypeKind.INTERSECTION) {
                return and(combinedIntersectionType.types, memberA => isAssignableToSimpleTypeInternal(memberA, typeB, options));
            }
            return isAssignableToSimpleTypeInternal(combinedIntersectionType, typeB, options);
        }
        // Interfaces
        case exports.SimpleTypeKind.INTERFACE:
        case exports.SimpleTypeKind.OBJECT:
        case exports.SimpleTypeKind.CLASS: {
            // If there are no members check that "typeB" is not assignable to a set of incompatible type kinds
            const strictNullChecks = options.config.strictNullChecks == null && options.config.strict;
            const objHasZeroMembers = "members" in typeA && (typeA.members == null || typeA.members.length === 0 || (!strictNullChecks && !typeA.members.some(m => !m.optional) && typeB.kind === exports.SimpleTypeKind.UNKNOWN));
            const clsHasZeroMembers = typeA.kind === "CLASS" && typeA.properties.length === 0 && typeA.methods.length === 0;
            if (objHasZeroMembers || clsHasZeroMembers) {
                return !isAssignableToSimpleTypeKind(typeB, [exports.SimpleTypeKind.NULL, exports.SimpleTypeKind.UNDEFINED, exports.SimpleTypeKind.NEVER, exports.SimpleTypeKind.VOID, ...(strictNullChecks ? [exports.SimpleTypeKind.UNKNOWN] : [])], {
                    op: "or",
                    matchAny: false
                });
            }
            switch (typeB.kind) {
                case exports.SimpleTypeKind.INTERFACE:
                case exports.SimpleTypeKind.OBJECT:
                case exports.SimpleTypeKind.CLASS: {
                    const membersA = typeA.kind === exports.SimpleTypeKind.CLASS ? [...typeA.methods, ...typeA.properties] : typeA.members || [];
                    const membersB = typeB.kind === exports.SimpleTypeKind.CLASS ? [...typeB.methods, ...typeB.properties] : typeB.members || [];
                    const newOptions = {
                        ...options,
                        insideType: new Set([...options.insideType, typeA, typeB])
                    };
                    // Check how many properties typeB has in common with typeA.
                    // They are not assignable if typeB has 0 properties in common with typeA, and there are more than 0 properties in typeB.
                    let propertiesInCommon = 0;
                    return (and(membersA, memberA => {
                        // Make sure that every required prop in typeA is present
                        const memberB = membersB.find(memberB => memberA.name === memberB.name);
                        if (memberB != null)
                            propertiesInCommon += 1;
                        return memberB == null ? memberA.optional : true;
                    }) &&
                        (propertiesInCommon > 0 || membersB.length === 0) &&
                        and(membersB, memberB => {
                            // Ensure that every member in typeB is assignable to corresponding members in typeA
                            const memberA = membersA.find(memberA => memberA.name === memberB.name);
                            if (memberA == null) {
                                return true;
                            }
                            return isAssignableToSimpleTypeInternal(memberA.type, memberB.type, newOptions);
                        }));
                }
                default:
                    return false;
            }
        }
        case exports.SimpleTypeKind.TUPLE: {
            if (typeB.kind !== exports.SimpleTypeKind.TUPLE)
                return false;
            // Compare the length of each tuple, but compare the length type instead of the actual length
            // We compare the length type because Typescript compares the type of the "length" member of tuples
            if (!isAssignableToSimpleTypeInternal(getTupleLengthType(typeA), getTupleLengthType(typeB), options)) {
                return false;
            }
            // Compare if typeB elements are assignable to typeA's rest element
            // Example: [string, ...boolean[]] === [any, true, 123]
            if (typeA.hasRestElement && typeB.members.length > typeA.members.length) {
                return and(typeB.members.slice(typeA.members.length), (memberB, i) => {
                    return isAssignableToSimpleTypeInternal(typeA.members[typeA.members.length - 1].type, memberB.type, options);
                });
            }
            // Compare that every type of typeB is assignable to corresponding members in typeA
            return and(typeA.members, (memberA, i) => {
                const memberB = typeB.members[i];
                if (memberB == null)
                    return memberA.optional;
                return isAssignableToSimpleTypeInternal(memberA.type, memberB.type, options);
            });
        }
        case exports.SimpleTypeKind.PROMISE:
            return typeB.kind === exports.SimpleTypeKind.PROMISE && isAssignableToSimpleTypeInternal(typeA.type, typeB.type, options);
        case exports.SimpleTypeKind.DATE:
            return typeB.kind === exports.SimpleTypeKind.DATE;
        //default:
        //throw new Error(`Unsupported comparison: ${typeA.kind}`);
    }
}
function extendTypeParameterMap(genericType, existingMap) {
    if ("typeParameters" in genericType.target) {
        const parameterEntries = (genericType.target.typeParameters || []).map((parameter, i) => [parameter.name, genericType.typeArguments[i] || parameter.default || { kind: exports.SimpleTypeKind.ANY }]);
        const allParameterEntries = [...existingMap.entries(), ...parameterEntries];
        return new Map(allParameterEntries);
    }
    return existingMap;
}

const simpleTypeCache = new WeakMap();
const isAssignableTypeCache = new WeakMap();
function isAssignableToType(typeA, typeB, checkerOrOptions, options) {
    if (typeA === typeB)
        return true;
    // Get the correct TypeChecker
    const checker = isTypeChecker(checkerOrOptions) ? checkerOrOptions : isProgram(checkerOrOptions) ? checkerOrOptions.getTypeChecker() : undefined;
    // Get the correct options. Potentially merge user given options with program options.
    options = {
        ...(checkerOrOptions == null ? {} : isProgram(checkerOrOptions) ? checkerOrOptions.getCompilerOptions() : isTypeChecker(checkerOrOptions) ? {} : checkerOrOptions),
        ...(options || {})
    };
    // Check if the types are nodes (in which case we need to get the type of the node)
    typeA = isNode(typeA) ? checker.getTypeAtLocation(typeA) : typeA;
    typeB = isNode(typeB) ? checker.getTypeAtLocation(typeB) : typeB;
    // Convert the TS types to SimpleTypes
    const simpleTypeA = isSimpleType(typeA) ? typeA : toSimpleType(typeA, checker, simpleTypeCache);
    const simpleTypeB = isSimpleType(typeB) ? typeB : toSimpleType(typeB, checker, simpleTypeCache);
    const typeAResultCache = (() => {
        if (isAssignableTypeCache.has(simpleTypeA)) {
            return isAssignableTypeCache.get(simpleTypeA);
        }
        const newResultCache = new WeakMap();
        isAssignableTypeCache.set(simpleTypeA, newResultCache);
        return newResultCache;
    })();
    if (typeAResultCache.has(simpleTypeB)) {
        return typeAResultCache.get(simpleTypeB);
    }
    /*console.log("Type A");
     console.dir(simpleTypeA, { depth: 5 });
     console.log("Type B");
     console.dir(simpleTypeB, { depth: 5 });*/
    const result = isAssignableToSimpleType(simpleTypeA, simpleTypeB, options);
    typeAResultCache.set(simpleTypeB, result);
    return result;
}

function isAssignableToValue(type, value, checker) {
    if (isSimpleType(type)) {
        if (typeof value === "string") {
            return isAssignableToType(type, {
                kind: exports.SimpleTypeKind.STRING_LITERAL,
                value
            }, { strict: true });
        }
        else if (typeof value === "number") {
            return isAssignableToType(type, {
                kind: exports.SimpleTypeKind.NUMBER_LITERAL,
                value
            }, { strict: true });
        }
        else if (typeof value === "boolean") {
            return isAssignableToType(type, {
                kind: exports.SimpleTypeKind.BOOLEAN_LITERAL,
                value
            }, { strict: true });
        }
        else if (value instanceof Promise) {
            return isAssignableToType(type, {
                kind: exports.SimpleTypeKind.PROMISE,
                type: { kind: exports.SimpleTypeKind.ANY }
            }, { strict: true });
        }
        else if (value instanceof Date) {
            return isAssignableToType(type, {
                kind: exports.SimpleTypeKind.DATE
            }, { strict: true });
        }
        throw new Error(`Comparing type "${type.kind}" to value ${value}, type ${typeof value} not supported yet.`);
    }
    return isAssignableToValue(toSimpleType(type, checker), value);
}

/**
 * Converts a simple type to a string.
 * @param type Simple Type
 */
function simpleTypeToString(type) {
    //}, options: SimpleTypeToStringOptions): string {
    switch (type.kind) {
        case exports.SimpleTypeKind.CIRCULAR_TYPE_REF:
            return type.ref.name || "[Circular]";
        case exports.SimpleTypeKind.BOOLEAN_LITERAL:
            return String(type.value);
        case exports.SimpleTypeKind.NUMBER_LITERAL:
            return String(type.value);
        case exports.SimpleTypeKind.STRING_LITERAL:
            return `"${type.value}"`;
        case exports.SimpleTypeKind.BIG_INT_LITERAL:
            return `${type.value}n`;
        case exports.SimpleTypeKind.STRING:
            return "string";
        case exports.SimpleTypeKind.BOOLEAN:
            return "boolean";
        case exports.SimpleTypeKind.NUMBER:
            return "number";
        case exports.SimpleTypeKind.BIG_INT:
            return "bigint";
        case exports.SimpleTypeKind.UNDEFINED:
            return "undefined";
        case exports.SimpleTypeKind.NULL:
            return "null";
        case exports.SimpleTypeKind.ANY:
            return "any";
        case exports.SimpleTypeKind.UNKNOWN:
            return "unknown";
        case exports.SimpleTypeKind.VOID:
            return "void";
        case exports.SimpleTypeKind.NEVER:
            return "never";
        case exports.SimpleTypeKind.FUNCTION:
        case exports.SimpleTypeKind.METHOD: {
            if (type.kind === exports.SimpleTypeKind.FUNCTION && type.name != null)
                return type.name;
            const argText = functionArgTypesToString(type.argTypes || []);
            return `${type.typeParameters != null ? `<${type.typeParameters.map(tp => tp.name).join(",")}>` : ""}(${argText})${type.returnType != null ? ` => ${simpleTypeToString(type.returnType)}` : ""}`;
        }
        case exports.SimpleTypeKind.ARRAY: {
            const hasMultipleTypes = [exports.SimpleTypeKind.UNION, exports.SimpleTypeKind.INTERSECTION].includes(type.type.kind);
            let memberType = simpleTypeToString(type.type);
            if (type.name != null && ["ArrayLike", "ReadonlyArray"].includes(type.name))
                return `${type.name}<${memberType}>`;
            if (hasMultipleTypes && type.type.name == null)
                memberType = `(${memberType})`;
            return `${memberType}[]`;
        }
        case exports.SimpleTypeKind.UNION: {
            if (type.name != null)
                return type.name;
            return type.types.map(simpleTypeToString).join(" | ");
        }
        case exports.SimpleTypeKind.ENUM:
            return type.name;
        case exports.SimpleTypeKind.ENUM_MEMBER:
            return type.fullName;
        case exports.SimpleTypeKind.INTERSECTION:
            if (type.name != null)
                return type.name;
            return type.types.map(simpleTypeToString).join(" & ");
        case exports.SimpleTypeKind.INTERFACE:
            if (type.name != null)
                return type.name;
        // this fallthrough is intentional
        case exports.SimpleTypeKind.OBJECT: {
            if (type.members == null || type.members.length === 0)
                return "{}";
            return `{ ${type.members
                .map(member => {
                // this check needs to change in the future
                if (member.type.kind === exports.SimpleTypeKind.FUNCTION || member.type.kind === exports.SimpleTypeKind.METHOD) {
                    const result = simpleTypeToString(member.type);
                    return `${member.name}${result.replace(" => ", ": ")}`;
                }
                return `${member.name}: ${simpleTypeToString(member.type)}`;
            })
                .join("; ")}${type.members.length > 0 ? ";" : ""} }`;
        }
        case exports.SimpleTypeKind.TUPLE:
            return `[${type.members.map(member => `${simpleTypeToString(member.type)}${member.optional ? "?" : ""}`).join(", ")}]`;
        case exports.SimpleTypeKind.GENERIC_ARGUMENTS: {
            const { target, typeArguments } = type;
            return typeArguments.length === 0 ? target.name || "" : `${target.name}<${typeArguments.map(simpleTypeToString).join(", ")}>`;
        }
        case exports.SimpleTypeKind.PROMISE:
            return `${type.name || "Promise"}<${simpleTypeToString(type.type)}>`;
        case exports.SimpleTypeKind.DATE:
            return "Date";
        default:
            return type.name || "";
    }
}
function functionArgTypesToString(argTypes) {
    return argTypes
        .map(arg => {
        return `${arg.spread ? "..." : ""}${arg.name}${arg.optional ? "?" : ""}: ${simpleTypeToString(arg.type)}`;
    })
        .join(", ");
}

function toTypeString(type, checker) {
    if (isSimpleType(type)) {
        return simpleTypeToString(type);
    }
    // Use the typescript checker to return a string for a type
    return checker.typeToString(type);
}

exports.IMPLICIT_GENERIC = IMPLICIT_GENERIC;
exports.LITERAL_TYPE_KINDS = LITERAL_TYPE_KINDS;
exports.LITERAL_TYPE_TO_PRIMITIVE_TYPE_MAP = LITERAL_TYPE_TO_PRIMITIVE_TYPE_MAP;
exports.PRIMITIVE_TYPE_KINDS = PRIMITIVE_TYPE_KINDS;
exports.PRIMITIVE_TYPE_TO_LITERAL_MAP = PRIMITIVE_TYPE_TO_LITERAL_MAP;
exports.isAssignableToPrimitiveType = isAssignableToPrimitiveType;
exports.isAssignableToSimpleTypeKind = isAssignableToSimpleTypeKind;
exports.isAssignableToType = isAssignableToType;
exports.isAssignableToValue = isAssignableToValue;
exports.isImplicitGenericType = isImplicitGenericType;
exports.isSimpleType = isSimpleType;
exports.isSimpleTypeLiteral = isSimpleTypeLiteral;
exports.isSimpleTypePrimitive = isSimpleTypePrimitive;
exports.setTypescriptModule = setTypescriptModule;
exports.simpleTypeToString = simpleTypeToString;
exports.toSimpleType = toSimpleType;
exports.toTypeString = toTypeString;
