import { BigIntLiteralType, Declaration, GenericType, LiteralType, Node, ObjectType, Program, Symbol, TupleTypeReference, Type, TypeChecker, TypeReference, UniqueESSymbolType } from "typescript";
declare enum SimpleTypeKind {
    STRING_LITERAL = "STRING_LITERAL",
    NUMBER_LITERAL = "NUMBER_LITERAL",
    BOOLEAN_LITERAL = "BOOLEAN_LITERAL",
    BIG_INT_LITERAL = "BIG_INT_LITERAL",
    STRING = "STRING",
    NUMBER = "NUMBER",
    BOOLEAN = "BOOLEAN",
    BIG_INT = "BIG_INT",
    NULL = "NULL",
    UNDEFINED = "UNDEFINED",
    NEVER = "NEVER",
    ANY = "ANY",
    UNKNOWN = "UNKNOWN",
    VOID = "VOID",
    UNION = "UNION",
    ENUM = "ENUM",
    ENUM_MEMBER = "ENUM_MEMBER",
    INTERSECTION = "INTERSECTION",
    TUPLE = "TUPLE",
    INTERFACE = "INTERFACE",
    OBJECT = "OBJECT",
    FUNCTION = "FUNCTION",
    METHOD = "METHOD",
    CLASS = "CLASS",
    CIRCULAR_TYPE_REF = "CIRCULAR_TYPE_REF",
    GENERIC_ARGUMENTS = "GENERIC_ARGUMENTS",
    GENERIC_PARAMETER = "GENERIC_PARAMETER",
    ALIAS = "ALIAS",
    DATE = "DATE",
    ARRAY = "ARRAY",
    PROMISE = "PROMISE"
}
declare enum SimpleTypeModifierKind {
    EXPORT = "EXPORT",
    AMBIENT = "AMBIENT",
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE",
    PROTECTED = "PROTECTED",
    STATIC = "STATIC",
    READONLY = "READONLY",
    ABSTRACT = "ABSTRACT",
    ASYNC = "ASYNC",
    DEFAULT = "DEFAULT"
}
interface SimpleTypeBase {
    kind: SimpleTypeKind;
    name?: string;
}
interface SimpleTypeMember {
    optional: boolean;
    type: SimpleType;
}
interface SimpleTypeMemberNamed extends SimpleTypeMember {
    name: string;
}
interface SimpleTypeClassMember extends SimpleTypeMemberNamed {
    modifiers: SimpleTypeModifierKind[];
}
interface SimpleTypeAlias extends SimpleTypeBase {
    kind: SimpleTypeKind.ALIAS;
    name: string;
    target: SimpleType;
    typeParameters?: SimpleTypeGenericParameter[];
}
interface SimpleTypeDate extends SimpleTypeBase {
    kind: SimpleTypeKind.DATE;
}
interface SimpleTypeClass extends SimpleTypeBase {
    kind: SimpleTypeKind.CLASS;
    ctor?: SimpleTypeFunction;
    typeParameters?: SimpleTypeGenericParameter[];
    properties: SimpleTypeClassMember[];
    methods: SimpleTypeClassMember[];
}
interface SimpleTypeFunctionArgument {
    name: string;
    type: SimpleType;
    optional: boolean;
    spread: boolean;
    initializer: boolean;
}
interface SimpleTypeFunction extends SimpleTypeBase {
    kind: SimpleTypeKind.FUNCTION;
    argTypes?: SimpleTypeFunctionArgument[];
    typeParameters?: SimpleTypeGenericParameter[];
    returnType?: SimpleType;
}
interface SimpleTypeMethod extends SimpleTypeBase {
    kind: SimpleTypeKind.METHOD;
    argTypes: SimpleTypeFunctionArgument[];
    typeParameters?: SimpleTypeGenericParameter[];
    returnType: SimpleType;
}
interface SimpleTypeInterface extends SimpleTypeBase {
    kind: SimpleTypeKind.INTERFACE;
    members?: SimpleTypeMemberNamed[];
}
interface SimpleTypeGenericArguments extends SimpleTypeBase {
    kind: SimpleTypeKind.GENERIC_ARGUMENTS;
    name?: undefined;
    target: SimpleType;
    typeArguments: SimpleType[];
}
interface SimpleTypeGenericParameter extends SimpleTypeBase {
    name: string;
    kind: SimpleTypeKind.GENERIC_PARAMETER;
    default?: SimpleType;
}
interface SimpleTypeObject extends SimpleTypeBase {
    kind: SimpleTypeKind.OBJECT;
    members?: SimpleTypeMemberNamed[];
}
interface SimpleTypeTuple extends SimpleTypeBase {
    kind: SimpleTypeKind.TUPLE;
    members: SimpleTypeMember[];
    hasRestElement?: boolean;
}
interface SimpleTypeArray extends SimpleTypeBase {
    kind: SimpleTypeKind.ARRAY;
    type: SimpleType;
}
interface SimpleTypePromise extends SimpleTypeBase {
    kind: SimpleTypeKind.PROMISE;
    type: SimpleType;
}
interface SimpleTypeEnumMember extends SimpleTypeBase {
    kind: SimpleTypeKind.ENUM_MEMBER;
    fullName: string;
    name: string;
    type: SimpleTypePrimitive;
}
interface SimpleTypeEnum extends SimpleTypeBase {
    name: string;
    kind: SimpleTypeKind.ENUM;
    types: SimpleTypeEnumMember[];
}
interface SimpleTypeUnion extends SimpleTypeBase {
    kind: SimpleTypeKind.UNION;
    types: SimpleType[];
}
interface SimpleTypeIntersection extends SimpleTypeBase {
    kind: SimpleTypeKind.INTERSECTION;
    types: SimpleType[];
}
interface SimpleTypeBigIntLiteral extends SimpleTypeBase {
    kind: SimpleTypeKind.BIG_INT_LITERAL;
    value: bigint;
}
interface SimpleTypeStringLiteral extends SimpleTypeBase {
    kind: SimpleTypeKind.STRING_LITERAL;
    value: string;
}
interface SimpleTypeNumberLiteral extends SimpleTypeBase {
    kind: SimpleTypeKind.NUMBER_LITERAL;
    value: number;
}
interface SimpleTypeBooleanLiteral extends SimpleTypeBase {
    kind: SimpleTypeKind.BOOLEAN_LITERAL;
    value: boolean;
}
interface SimpleTypeString extends SimpleTypeBase {
    kind: SimpleTypeKind.STRING;
}
interface SimpleTypeNumber extends SimpleTypeBase {
    kind: SimpleTypeKind.NUMBER;
}
interface SimpleTypeBoolean extends SimpleTypeBase {
    kind: SimpleTypeKind.BOOLEAN;
}
interface SimpleTypeBigInt extends SimpleTypeBase {
    kind: SimpleTypeKind.BIG_INT;
}
interface SimpleTypeNull extends SimpleTypeBase {
    kind: SimpleTypeKind.NULL;
}
interface SimpleTypeNever extends SimpleTypeBase {
    kind: SimpleTypeKind.NEVER;
}
interface SimpleTypeUndefined extends SimpleTypeBase {
    kind: SimpleTypeKind.UNDEFINED;
}
interface SimpleTypeAny extends SimpleTypeBase {
    kind: SimpleTypeKind.ANY;
}
interface SimpleTypeUnknown extends SimpleTypeBase {
    kind: SimpleTypeKind.UNKNOWN;
}
interface SimpleTypeVoid extends SimpleTypeBase {
    kind: SimpleTypeKind.VOID;
}
interface SimpleTypeCircularRef extends SimpleTypeBase {
    kind: SimpleTypeKind.CIRCULAR_TYPE_REF;
    ref: SimpleType;
}
declare type SimpleType = SimpleTypeBigIntLiteral | SimpleTypeEnumMember | SimpleTypeEnum | SimpleTypeCircularRef | SimpleTypeClass | SimpleTypeFunction | SimpleTypeObject | SimpleTypeInterface | SimpleTypeTuple | SimpleTypeArray | SimpleTypeUnion | SimpleTypeIntersection | SimpleTypeStringLiteral | SimpleTypeNumberLiteral | SimpleTypeBooleanLiteral | SimpleTypeString | SimpleTypeNumber | SimpleTypeBoolean | SimpleTypeBigInt | SimpleTypeNull | SimpleTypeUndefined | SimpleTypeNever | SimpleTypeAny | SimpleTypeMethod | SimpleTypeVoid | SimpleTypePromise | SimpleTypeUnknown | SimpleTypeAlias | SimpleTypeDate | SimpleTypeGenericArguments | SimpleTypeGenericParameter;
declare function isSimpleType(type: any): type is SimpleType;
declare type SimpleTypeLiteral = SimpleTypeBigIntLiteral | SimpleTypeBooleanLiteral | SimpleTypeStringLiteral | SimpleTypeNumberLiteral;
declare const LITERAL_TYPE_KINDS: SimpleTypeKind[];
declare function isSimpleTypeLiteral(type: SimpleType): type is SimpleTypeLiteral;
declare type SimpleTypePrimitive = SimpleTypeLiteral | SimpleTypeString | SimpleTypeNumber | SimpleTypeBoolean | SimpleTypeBigInt | SimpleTypeNull | SimpleTypeUndefined;
declare const PRIMITIVE_TYPE_KINDS: SimpleTypeKind[];
declare function isSimpleTypePrimitive(type: SimpleType): type is SimpleTypePrimitive;
declare const PRIMITIVE_TYPE_TO_LITERAL_MAP: Record<SimpleTypeKind, SimpleTypeKind | undefined>;
declare const LITERAL_TYPE_TO_PRIMITIVE_TYPE_MAP: Record<SimpleTypeKind, SimpleTypeKind | undefined>;
declare const IMPLICIT_GENERIC: SimpleTypeKind[];
declare function isImplicitGenericType(type: SimpleType): type is SimpleTypeArray | SimpleTypeTuple | SimpleTypePromise;
interface SimpleTypeComparisonOptions {
    strict?: boolean;
    strictNullChecks?: boolean;
    strictFunctionTypes?: boolean;
    noStrictGenericChecks?: boolean;
    isAssignable?: (typeA: SimpleType, typeB: SimpleType, options: SimpleTypeComparisonOptions) => boolean | undefined | void;
}
declare function setTypescriptModule(newModule: typeof import("typescript")): void;
/**
 * Converts a Typescript type to a "SimpleType"
 * @param type The type to convert.
 * @param checker
 * @param cache
 */
declare function toSimpleType(type: Node, checker: TypeChecker, cache?: WeakMap<Type, SimpleType>): SimpleType;
declare function toSimpleType(type: Type, checker: TypeChecker, cache?: WeakMap<Type, SimpleType>): SimpleType;
interface ToSimpleTypeOptions {
    circularCache: WeakMap<Type, SimpleType>;
    cache: WeakMap<Type, SimpleType>;
    checker: TypeChecker;
}
interface SimpleTypeKindComparisonOptions {
    op?: "and" | "or";
    matchAny?: boolean;
}
/**
 * Checks if a simple type kind is assignable to a type.
 * @param type The type to check
 * @param kind The simple type kind to check
 * @param kind The simple type kind to check
 * @param checker TypeCHecker if type is a typescript type
 * @param options Options
 */
declare function isAssignableToSimpleTypeKind(type: SimpleType, kind: SimpleTypeKind | SimpleTypeKind[], options?: SimpleTypeKindComparisonOptions): boolean;
declare function isAssignableToSimpleTypeKind(type: Type, kind: SimpleTypeKind | SimpleTypeKind[], checker: TypeChecker, options?: SimpleTypeKindComparisonOptions): boolean;
declare function isAssignableToSimpleTypeKind(type: Type | SimpleType, kind: SimpleTypeKind | SimpleTypeKind[], checker: TypeChecker, options?: SimpleTypeKindComparisonOptions): boolean;
/**
 * Tests a type is assignable to a primitive type.
 * @param type The type to test.
 * @param checker TypeChecker if type is a typescript type.
 */
declare function isAssignableToPrimitiveType(type: SimpleType): boolean;
declare function isAssignableToPrimitiveType(type: Type, checker: TypeChecker): boolean;
declare function isAssignableToPrimitiveType(type: Type | SimpleType, checker: TypeChecker): boolean;
/**
 * Tests if "typeA = typeB" in strict mode.
 * @param typeA - Type A
 * @param typeB - Type B
 * @param checkerOrOptions
 * @param options
 */
declare function isAssignableToType(typeA: SimpleType, typeB: SimpleType, options?: SimpleTypeComparisonOptions): boolean;
declare function isAssignableToType(typeA: SimpleType | Type | Node, typeB: SimpleType, checker: TypeChecker | Program, options?: SimpleTypeComparisonOptions): boolean;
declare function isAssignableToType(typeA: SimpleType, typeB: SimpleType | Type | Node, checker: TypeChecker | Program, options?: SimpleTypeComparisonOptions): boolean;
declare function isAssignableToType(typeA: Type | Node, typeB: Type | Node, checker: TypeChecker | Program, options?: SimpleTypeComparisonOptions): boolean;
declare function isAssignableToType(typeA: Type | Node | SimpleType, typeB: Type | Node | SimpleType, checker: Program | TypeChecker | SimpleTypeComparisonOptions, options?: SimpleTypeComparisonOptions): boolean;
/**
 * Tests if a type is assignable to a value.
 * Tests "type = value" in strict mode.
 * @param type The type to test.
 * @param value The value to test.
 */
declare function isAssignableToValue(type: SimpleType, value: any): boolean;
declare function isAssignableToValue(type: Type, value: any, checker: TypeChecker): boolean;
declare function isAssignableToValue(type: SimpleType | Type, value: any, checker: TypeChecker): boolean;
/**
 * Converts a simple type to a string.
 * @param type Simple Type
 */
declare function simpleTypeToString(type: SimpleType): string;
/**
 * Returns a string representation of a given type.
 * @param simpleType
 */
declare function toTypeString(simpleType: SimpleType): string;
declare function toTypeString(type: SimpleType | Type, checker: TypeChecker): string;
export { SimpleTypeComparisonOptions, isAssignableToPrimitiveType, isAssignableToType, isAssignableToValue, toSimpleType, ToSimpleTypeOptions, toTypeString, SimpleTypeKindComparisonOptions, isAssignableToSimpleTypeKind, simpleTypeToString, SimpleTypeKind, SimpleTypeModifierKind, SimpleTypeBase, SimpleTypeMember, SimpleTypeMemberNamed, SimpleTypeClassMember, SimpleTypeAlias, SimpleTypeDate, SimpleTypeClass, SimpleTypeFunctionArgument, SimpleTypeFunction, SimpleTypeMethod, SimpleTypeInterface, SimpleTypeGenericArguments, SimpleTypeGenericParameter, SimpleTypeObject, SimpleTypeTuple, SimpleTypeArray, SimpleTypePromise, SimpleTypeEnumMember, SimpleTypeEnum, SimpleTypeUnion, SimpleTypeIntersection, SimpleTypeBigIntLiteral, SimpleTypeStringLiteral, SimpleTypeNumberLiteral, SimpleTypeBooleanLiteral, SimpleTypeString, SimpleTypeNumber, SimpleTypeBoolean, SimpleTypeBigInt, SimpleTypeNull, SimpleTypeNever, SimpleTypeUndefined, SimpleTypeAny, SimpleTypeUnknown, SimpleTypeVoid, SimpleTypeCircularRef, SimpleType, isSimpleType, SimpleTypeLiteral, LITERAL_TYPE_KINDS, isSimpleTypeLiteral, SimpleTypePrimitive, PRIMITIVE_TYPE_KINDS, isSimpleTypePrimitive, PRIMITIVE_TYPE_TO_LITERAL_MAP, LITERAL_TYPE_TO_PRIMITIVE_TYPE_MAP, IMPLICIT_GENERIC, isImplicitGenericType, setTypescriptModule };
//# sourceMappingURL=index.cjs.d.ts.map