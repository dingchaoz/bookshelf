'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tsModule = require('typescript');
var tsSimpleType = require('ts-simple-type');
var fs = require('fs');
var path = require('path');
var fastGlob = _interopDefault(require('fast-glob'));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/**
 * Parses a jsdoc tag into type, name and comment
 * @param tag
 */
function parseJsDocTagComment(tag) {
    if (typeof tag !== "string" && tag.comment == null)
        return {};
    var text = typeof tag === "string" ? tag : tag.comment;
    if (text.trim().startsWith("@")) {
        var trimResult = text.match(/\s?@.+\s(.+)/);
        if (trimResult != null) {
            text = trimResult[1];
        }
    }
    /**
     * {MyType} MyName - MyComment
     * {MyType} MyName
     * {MyType} - MyComment
     * MyName - MyComment
     * {MyType}
     * MyComment
     */
    var regex = /^(\s*?\{(?<type>.*)\})?(((?<name1>.+)(\s\-\s)(?<comment1>.+))|(\s?\-\s)(?<comment2>.+)|(?<name2>.*?))$/;
    var result = text.trim().match(regex);
    if (result == null || result.groups == null)
        return {};
    var type = result.groups["type"];
    var name = result.groups["name1"] || result.groups["name2"];
    var comment = result.groups["comment1"] || result.groups["comment2"];
    return {
        type: (type && type.trim()) || undefined,
        name: (name && name.trim()) || undefined,
        comment: (comment && comment.trim()) || undefined
    };
}
/**
 * Returns jsdoc for a given node.
 * @param node
 * @param ts
 */
function getJsDoc(node, ts) {
    var e_1, _a;
    var docs = node.jsDoc || [];
    try {
        for (var docs_1 = __values(docs), docs_1_1 = docs_1.next(); !docs_1_1.done; docs_1_1 = docs_1.next()) {
            var doc = docs_1_1.value;
            if (ts.isJSDoc(doc)) {
                return {
                    comment: doc.comment == null ? undefined : String(doc.comment),
                    node: doc,
                    tags: doc.tags == null
                        ? []
                        : doc.tags.map(function (node) { return ({
                            node: node,
                            tag: String(node.tagName.escapedText),
                            comment: node.comment == null ? undefined : String(node.comment)
                        }); })
                };
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (docs_1_1 && !docs_1_1.done && (_a = docs_1.return)) _a.call(docs_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
/**
 * Converts a given string to a SimpleType
 * Defaults to ANY
 * See http://usejsdoc.org/tags-type.html
 * @param str
 */
function parseJsDocTypeString(str) {
    // Fail safe if "str" is somehow undefined
    if (str == null) {
        return { kind: tsSimpleType.SimpleTypeKind.ANY };
    }
    // Parse normal types
    switch (str.toLowerCase()) {
        case "undefined":
            return { kind: tsSimpleType.SimpleTypeKind.UNDEFINED };
        case "null":
            return { kind: tsSimpleType.SimpleTypeKind.NULL };
        case "string":
            return { kind: tsSimpleType.SimpleTypeKind.STRING };
        case "number":
            return { kind: tsSimpleType.SimpleTypeKind.NUMBER };
        case "boolean":
            return { kind: tsSimpleType.SimpleTypeKind.BOOLEAN };
        case "array":
            return { kind: tsSimpleType.SimpleTypeKind.ARRAY, type: { kind: tsSimpleType.SimpleTypeKind.ANY } };
        case "object":
            return { kind: tsSimpleType.SimpleTypeKind.OBJECT, members: [] };
        case "any":
        case "*":
            return { kind: tsSimpleType.SimpleTypeKind.ANY };
    }
    // Match
    //  {  string  }
    if (str.startsWith(" ") || str.endsWith(" ")) {
        return parseJsDocTypeString(str.trim());
    }
    // Match:
    //   {string|number}
    if (str.includes("|")) {
        return {
            kind: tsSimpleType.SimpleTypeKind.UNION,
            types: str.split("|").map(function (str) {
                var childType = parseJsDocTypeString(str);
                // Convert ANY types to string literals so that {on|off} is "on"|"off" and not ANY|ANY
                if (childType.kind === tsSimpleType.SimpleTypeKind.ANY) {
                    return {
                        kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL,
                        value: str
                    };
                }
                return childType;
            })
        };
    }
    // Match:
    //  {?number}       (nullable)
    //  {!number}       (not nullable)
    //  {...number}     (array of)
    var prefixMatch = str.match(/^(\?|!|(\.\.\.))(.+)$/);
    if (prefixMatch != null) {
        var modifier = prefixMatch[1];
        var type = parseJsDocTypeString(prefixMatch[3]);
        switch (modifier) {
            case "?":
                return {
                    kind: tsSimpleType.SimpleTypeKind.UNION,
                    types: [
                        {
                            kind: tsSimpleType.SimpleTypeKind.NULL
                        },
                        type
                    ]
                };
            case "!":
                return type;
            case "...":
                return {
                    kind: tsSimpleType.SimpleTypeKind.ARRAY,
                    type: type
                };
        }
    }
    // Match:
    //  {(......)}
    var parenMatch = str.match(/^\((.+)\)$/);
    if (parenMatch != null) {
        return parseJsDocTypeString(parenMatch[1]);
    }
    // Match
    //   {"red"}
    var stringLiteralMatch = str.match(/^["'](.+)["']$/);
    if (stringLiteralMatch != null) {
        return {
            kind: tsSimpleType.SimpleTypeKind.STRING_LITERAL,
            value: stringLiteralMatch[1]
        };
    }
    // Match
    //   {[number]}
    var arrayMatch = str.match(/^\[(.+)\]$/);
    if (arrayMatch != null) {
        return {
            kind: tsSimpleType.SimpleTypeKind.ARRAY,
            type: parseJsDocTypeString(arrayMatch[1])
        };
    }
    return { kind: tsSimpleType.SimpleTypeKind.ANY };
}
/**
 * Finds a @type jsdoc tag in the jsdoc and returns the corresponding simple type
 * @param jsDoc
 */
function getJsDocType(jsDoc) {
    if (jsDoc.tags != null) {
        var typeTag = jsDoc.tags.find(function (t) { return t.tag === "type"; });
        if (typeTag != null) {
            // We get the text of the node because typescript strips the type jsdoc tag under certain circumstances
            var parsedJsDoc = parseJsDocTagComment(typeTag.node.getText());
            if (parsedJsDoc.type != null) {
                return parseJsDocTypeString(parsedJsDoc.type);
            }
        }
    }
}

function parseDeclarationEvents(node, context) {
    var ts = context.ts, checker = context.checker;
    // new CustomEvent("my-event");
    if (ts.isNewExpression(node)) {
        var expression = node.expression, args = node.arguments, typeArguments = node.typeArguments;
        if (expression.getText() === "CustomEvent" && args && args.length >= 1) {
            var arg = args[0];
            if (ts.isStringLiteralLike(arg)) {
                var eventName = arg.text;
                // Either grab jsdoc from the new expression or from a possible call expression that its wrapped in
                var jsDoc = getJsDoc(expression, ts) ||
                    (function () { return ts.isCallLikeExpression(node.parent) && getJsDoc(node.parent.parent, ts); })() ||
                    (function () { return ts.isExpressionStatement(node.parent) && getJsDoc(node.parent, ts); })() ||
                    undefined;
                var type = (typeArguments && typeArguments[0] && checker.getTypeFromTypeNode(typeArguments[0])) || {
                    kind: tsSimpleType.SimpleTypeKind.ANY
                };
                return [
                    {
                        jsDoc: jsDoc,
                        name: eventName,
                        node: node,
                        type: type
                    }
                ];
            }
        }
    }
    return undefined;
}

/**
 * Resolves all relevant declarations of a specific node. Defaults to "interfaces and classes".
 * @param node
 * @param context
 */
function resolveDeclarations(node, context) {
    if (node == null)
        return [];
    var checker = context.checker, ts = context.ts;
    // Get the symbol
    var symbol = checker.getSymbolAtLocation(node);
    if (symbol == null)
        return [];
    // Resolve aliased symbols
    if (isAliasSymbol(symbol, ts)) {
        symbol = checker.getAliasedSymbol(symbol);
        if (symbol == null)
            return [];
    }
    // Filters all declarations
    var allDeclarations = symbol.getDeclarations() || [];
    var validDeclarations = allDeclarations.filter(function (declaration) { return !ts.isIdentifier(declaration); });
    if (validDeclarations.length > 0) {
        return validDeclarations;
    }
    else {
        var declaration = symbol.valueDeclaration;
        return declaration != null ? [declaration] : [];
    }
}
function isAliasSymbol(symbol, ts) {
    return (symbol.flags & ts.SymbolFlags.Alias) !== 0;
}
/**
 * Returns if a name is public (doesn't start with "_");
 * @param name
 */
function isPropNamePublic(name) {
    return !name.startsWith("_") && !name.startsWith("#");
}
/**
 * Returns if a node is public looking at its modifiers.
 * @param node
 * @param ts
 */
function hasPublicSetter(node, ts) {
    return (!hasModifier(node, ts.SyntaxKind.ProtectedKeyword) &&
        !hasModifier(node, ts.SyntaxKind.PrivateKeyword) &&
        !hasModifier(node, ts.SyntaxKind.ReadonlyKeyword) &&
        !hasModifier(node, ts.SyntaxKind.StaticKeyword) &&
        (ts.isIdentifier(node.name) ? isPropNamePublic(node.name.text) : true));
}
/**
 * Returns if a node has a specific modifier.
 * @param node
 * @param modifierKind
 */
function hasModifier(node, modifierKind) {
    if (node.modifiers == null)
        return false;
    return (node.modifiers || []).find(function (modifier) { return modifier.kind === modifierKind; }) != null;
}
/**
 * Returns all keys and corresponding interface/class declarations for keys in an interface.
 * @param interfaceDeclaration
 * @param ts
 * @param checker
 */
function getInterfaceKeys(interfaceDeclaration, _a) {
    var e_1, _b;
    var ts = _a.ts, checker = _a.checker;
    var extensions = [];
    try {
        for (var _c = __values(interfaceDeclaration.members), _d = _c.next(); !_d.done; _d = _c.next()) {
            var member = _d.value;
            // { "my-button": MyButton; }
            if (ts.isPropertySignature(member) && ts.isStringLiteral(member.name) && member.type != null && ts.isTypeReferenceNode(member.type)) {
                var key = member.name.text;
                var typeName = member.type.typeName;
                // { ____: MyButton; }
                var declaration = resolveDeclarations(typeName, { checker: checker, ts: ts })[0];
                if (declaration != null) {
                    extensions.push([key, declaration, member.name]);
                }
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return extensions;
}
function isNodeInLibDom(node) {
    return ("fileName" in node ? node.fileName : node.getSourceFile().fileName).endsWith("/lib/lib.dom.d.ts");
}
function isPropertyRequired(property, checker) {
    var type = checker.getTypeAtLocation(property);
    // Properties in external modules don't have initializers, so we cannot infer if the property is required or not
    if (isNodeInDeclarationFile(property)) {
        return false;
    }
    // The property cannot be required if it has an initializer.
    if (property.initializer != null) {
        return false;
    }
    // Take "myProp?: string" into account
    if (property.questionToken != null) {
        return false;
    }
    // "any" or "unknown" should never be required
    if (tsSimpleType.isAssignableToSimpleTypeKind(type, [tsSimpleType.SimpleTypeKind.ANY, tsSimpleType.SimpleTypeKind.UNKNOWN], checker, { op: "or" })) {
        return false;
    }
    // Return "not required" if the property doesn't have an initializer and no type node.
    // In this case the type could be determined by the jsdoc @type tag but cannot be "null" union if "strictNullCheck" is false.
    if (property.type == null) {
        return false;
    }
    return !tsSimpleType.isAssignableToSimpleTypeKind(type, [tsSimpleType.SimpleTypeKind.UNDEFINED, tsSimpleType.SimpleTypeKind.NULL], checker, { op: "or" });
}
function isNodeInDeclarationFile(node) {
    return node.getSourceFile().isDeclarationFile;
}
/**
 * Find a node recursively walking down the children of the tree. Depth first search.
 * @param node
 * @param test
 */
function findChild(node, test) {
    if (!node)
        return;
    if (test(node))
        return node;
    return node.forEachChild(function (child) { return findChild(child, test); });
}

/**
 * Takes a node and tries to resolve a constant value from it.
 * Returns undefined if no constant value can be resolved.
 * @param node
 * @param context
 */
function resolveNodeValue(node, context) {
    var e_1, _a;
    if (node == null)
        return undefined;
    var ts = context.ts, checker = context.checker;
    var depth = (context.depth || 0) + 1;
    // Always break when depth is larger than 10.
    // This ensures we cannot run into infinite recursion.
    if (depth > 10)
        return undefined;
    if (ts.isStringLiteralLike(node)) {
        return node.text;
    }
    else if (ts.isNumericLiteral(node)) {
        return Number(node.text);
    }
    else if (ts.isObjectLiteralExpression(node)) {
        try {
            // Try to parse object literal expressions as JSON by converting it to something parsable
            var regex = /([a-zA-Z1-9]*?):/gm;
            var json = node.getText().replace(regex, function (m) { return "\"" + m[0] + "\":"; });
            return JSON.parse(json);
        }
        catch (_b) {
            // If something crashes it probably means that the object is more complex.
            // Therefore do nothing
        }
    }
    else if (node.kind === ts.SyntaxKind.TrueKeyword) {
        return true;
    }
    else if (node.kind === ts.SyntaxKind.FalseKeyword) {
        return false;
    }
    else if (node.kind === ts.SyntaxKind.NullKeyword) {
        return null;
    }
    else if (node.kind === ts.SyntaxKind.UndefinedKeyword) {
        return undefined;
    }
    // Resolve initializers for variable declarations
    if (ts.isVariableDeclaration(node)) {
        return resolveNodeValue(node.initializer, __assign(__assign({}, context), { depth: depth }));
    }
    // Resolve value of a property access expression. For example: MyEnum.RED
    else if (ts.isPropertyAccessExpression(node)) {
        return resolveNodeValue(node.name, __assign(__assign({}, context), { depth: depth }));
    }
    // Resolve initializer value of enum members.
    else if (ts.isEnumMember(node)) {
        if (node.initializer != null) {
            return resolveNodeValue(node.initializer, __assign(__assign({}, context), { depth: depth }));
        }
        else {
            return node.parent.name.text + "." + node.name.getText();
        }
    }
    // Resolve values of variables.
    else if (ts.isIdentifier(node) && checker != null) {
        var declaration = resolveDeclarations(node, { checker: checker, ts: ts }).filter(function (decl) { return ts.isVariableDeclaration(decl); });
        return resolveNodeValue(declaration[0], __assign(__assign({}, context), { depth: depth }));
    }
    // Fallthrough
    //  - "my-value" as string
    //  - <any>"my-value"
    //  - ("my-value")
    else if (ts.isAsExpression(node) || ts.isTypeAssertion(node) || ts.isParenthesizedExpression(node)) {
        return resolveNodeValue(node.expression, __assign(__assign({}, context), { depth: depth }));
    }
    // static get is() {
    //    return "my-element";
    // }
    else if (ts.isGetAccessor(node) && node.body != null) {
        try {
            for (var _c = __values(node.body.statements), _d = _c.next(); !_d.done; _d = _c.next()) {
                var stm = _d.value;
                if (ts.isReturnStatement(stm)) {
                    return resolveNodeValue(stm.expression, __assign(__assign({}, context), { depth: depth }));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return undefined;
}

/**
 * Relax the type so that for example "string literal" become "string" and "function" become "any"
 * This is used for javascript files to provide type checking with Typescript type inferring
 * @param type
 */
function relaxType(type) {
    switch (type.kind) {
        case tsSimpleType.SimpleTypeKind.INTERSECTION:
        case tsSimpleType.SimpleTypeKind.UNION:
            return __assign(__assign({}, type), { types: type.types.map(function (t) { return relaxType(t); }) });
        case tsSimpleType.SimpleTypeKind.ENUM:
            return __assign(__assign({}, type), { types: type.types.map(function (t) { return relaxType(t); }) });
        case tsSimpleType.SimpleTypeKind.ARRAY:
            return __assign(__assign({}, type), { type: relaxType(type.type) });
        case tsSimpleType.SimpleTypeKind.PROMISE:
            return __assign(__assign({}, type), { type: relaxType(type.type) });
        case tsSimpleType.SimpleTypeKind.OBJECT:
            return {
                name: type.name,
                kind: tsSimpleType.SimpleTypeKind.OBJECT
            };
        case tsSimpleType.SimpleTypeKind.INTERFACE:
        case tsSimpleType.SimpleTypeKind.FUNCTION:
        case tsSimpleType.SimpleTypeKind.CLASS:
            return {
                name: type.name,
                kind: tsSimpleType.SimpleTypeKind.ANY
            };
        case tsSimpleType.SimpleTypeKind.NUMBER_LITERAL:
            return { kind: tsSimpleType.SimpleTypeKind.NUMBER };
        case tsSimpleType.SimpleTypeKind.STRING_LITERAL:
            return { kind: tsSimpleType.SimpleTypeKind.STRING };
        case tsSimpleType.SimpleTypeKind.BOOLEAN_LITERAL:
            return { kind: tsSimpleType.SimpleTypeKind.BOOLEAN };
        case tsSimpleType.SimpleTypeKind.BIG_INT_LITERAL:
            return { kind: tsSimpleType.SimpleTypeKind.BIG_INT };
        case tsSimpleType.SimpleTypeKind.ENUM_MEMBER:
            return __assign(__assign({}, type), { type: relaxType(type.type) });
        case tsSimpleType.SimpleTypeKind.ALIAS:
            return __assign(__assign({}, type), { target: relaxType(type.target) });
        default:
            return type;
    }
}

function parseDeclarationMembers(node, context) {
    var e_1, _a, e_2, _b;
    var ts = context.ts, checker = context.checker;
    // static get observedAttributes() { return ['c', 'l']; }
    if (ts.isGetAccessor(node) && hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        if (node.name.getText() === "observedAttributes" && node.body != null) {
            var members = [];
            var returnStatement = node.body.statements.find(function (statement) { return ts.isReturnStatement(statement); });
            if (returnStatement != null) {
                if (returnStatement.expression != null && ts.isArrayLiteralExpression(returnStatement.expression)) {
                    try {
                        // Emit an attribute for each string literal in the array.
                        for (var _c = __values(returnStatement.expression.elements), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var attrNameNode = _d.value;
                            var attrName = ts.isStringLiteralLike(attrNameNode) ? attrNameNode.text : undefined;
                            if (attrName == null)
                                continue;
                            members.push({
                                kind: "attribute",
                                attrName: attrName,
                                type: { kind: tsSimpleType.SimpleTypeKind.ANY },
                                node: attrNameNode
                            });
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
            }
            return members;
        }
    }
    // class { myProp = "hello"; }
    else if ((ts.isPropertyDeclaration(node) || ts.isPropertySignature(node)) && hasPublicSetter(node, ts)) {
        var name_1 = node.name, initializer = node.initializer;
        if (ts.isIdentifier(name_1) || ts.isStringLiteralLike(name_1)) {
            // Find default value based on initializer
            var def = "initializer" in node && node.initializer != null ? resolveNodeValue(initializer, context) : undefined;
            return [
                {
                    kind: "property",
                    propName: name_1.text,
                    type: checker.getTypeAtLocation(node),
                    required: isPropertyRequired(node, context.checker),
                    default: def,
                    jsDoc: getJsDoc(node, ts),
                    node: node
                }
            ];
        }
    }
    // class { 'hello'?: number }
    else if (ts.isConditionalExpression(node) && (ts.isStringLiteralLike(node.condition) || ts.isIdentifier(node.condition))) {
        return [
            {
                kind: "property",
                propName: node.condition.text,
                type: checker.getTypeAtLocation(node),
                jsDoc: getJsDoc(node, ts),
                node: node
            }
        ];
    }
    // class { set myProp(value: string) { ... } }
    else if (ts.isSetAccessor(node) && hasPublicSetter(node, ts)) {
        var name_2 = node.name, parameters = node.parameters;
        if (ts.isIdentifier(name_2) && parameters.length > 0) {
            var parameter = parameters[0];
            return [
                {
                    kind: "property",
                    propName: name_2.text,
                    type: context.checker.getTypeAtLocation(parameter),
                    jsDoc: getJsDoc(node, ts),
                    required: false,
                    node: node
                }
            ];
        }
    }
    // constructor { super(); this.title = "Hello"; }
    else if (ts.isConstructorDeclaration(node)) {
        if (node.body != null) {
            var assignments = node.body.statements
                .filter(function (stmt) { return ts.isExpressionStatement(stmt); })
                .map(function (stmt) { return stmt.expression; })
                .filter(function (exp) { return ts.isBinaryExpression(exp); });
            var members = [];
            var _loop_1 = function (assignment) {
                var left = assignment.left, right = assignment.right;
                if (ts.isPropertyAccessExpression(left)) {
                    if (left.expression.kind === ts.SyntaxKind.ThisKeyword) {
                        var propName_1 = left.name.getText();
                        var classFieldDeclaration = node.parent.members.find(function (m) { return ts.isPropertyDeclaration(m) || ts.isPropertySignature(m) || (ts.isSetAccessor(node) && node.name.getText() === propName_1); });
                        var parsedClassField = classFieldDeclaration == null ? undefined : parseDeclarationMembers(classFieldDeclaration, context);
                        if (isPropNamePublic(propName_1) && (classFieldDeclaration == null || parsedClassField != null)) {
                            var simpleType = relaxType(tsSimpleType.toSimpleType(checker.getTypeAtLocation(right), checker));
                            members.push({
                                kind: "property",
                                propName: propName_1,
                                default: resolveNodeValue(right, context),
                                type: simpleType,
                                jsDoc: getJsDoc(assignment.parent, ts),
                                required: false,
                                node: node
                            });
                        }
                    }
                }
            };
            try {
                for (var assignments_1 = __values(assignments), assignments_1_1 = assignments_1.next(); !assignments_1_1.done; assignments_1_1 = assignments_1.next()) {
                    var assignment = assignments_1_1.value;
                    _loop_1(assignment);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (assignments_1_1 && !assignments_1_1.done && (_b = assignments_1.return)) _b.call(assignments_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return members;
        }
    }
    return undefined;
}

/**
 * Visits custom element component definitions.
 * @param node
 * @param context
 */
function visitComponentDefinitions(node, context) {
    var e_1, _a, e_2, _b;
    var checker = context.checker, ts = context.ts;
    // customElements.define("my-element", MyElement)
    if (ts.isCallExpression(node)) {
        if (ts.isPropertyAccessExpression(node.expression)) {
            var leftExpression = node.expression.expression;
            if (ts.isPropertyAccessExpression(leftExpression) &&
                ts.isIdentifier(leftExpression.expression) &&
                leftExpression.expression.escapedText === "window") {
                leftExpression = leftExpression.name;
            }
            if (ts.isIdentifier(leftExpression) &&
                leftExpression.escapedText === "customElements" &&
                node.expression.name != null &&
                ts.isIdentifier(node.expression.name)) {
                // define("my-element", MyElement)
                if (node.expression.name.escapedText === "define") {
                    var _c = __read(node.arguments, 2), tagNameNode = _c[0], identifierNode = _c[1];
                    // ("my-element", MyElement)
                    var tagName = resolveNodeValue(tagNameNode, { ts: ts, checker: checker });
                    if (identifierNode != null && typeof tagName === "string") {
                        var definitionNode = node;
                        // (___, MyElement)
                        if (ts.isIdentifier(identifierNode)) {
                            var declarationNodes = resolveDeclarations(identifierNode, { checker: checker, ts: ts });
                            try {
                                for (var declarationNodes_1 = __values(declarationNodes), declarationNodes_1_1 = declarationNodes_1.next(); !declarationNodes_1_1.done; declarationNodes_1_1 = declarationNodes_1.next()) {
                                    var declarationNode = declarationNodes_1_1.value;
                                    context.emitDefinitionResult({
                                        tagName: tagName,
                                        identifierNode: identifierNode,
                                        definitionNode: definitionNode,
                                        declarationNode: declarationNode
                                    });
                                }
                            }
                            catch (e_1_1) { e_1 = { error: e_1_1 }; }
                            finally {
                                try {
                                    if (declarationNodes_1_1 && !declarationNodes_1_1.done && (_a = declarationNodes_1.return)) _a.call(declarationNodes_1);
                                }
                                finally { if (e_1) throw e_1.error; }
                            }
                        }
                        // (___, class { ... })
                        else if (ts.isClassLike(identifierNode) || ts.isInterfaceDeclaration(identifierNode)) {
                            context.emitDefinitionResult({
                                tagName: tagName,
                                identifierNode: identifierNode,
                                definitionNode: definitionNode,
                                declarationNode: identifierNode
                            });
                        }
                    }
                }
            }
        }
        return;
    }
    // interface HTMLElementTagNameMap { "my-button": MyButton; }
    if (ts.isInterfaceDeclaration(node) && ["HTMLElementTagNameMap", "ElementTagNameMap"].includes(node.name.text)) {
        var extensions = getInterfaceKeys(node, context);
        try {
            for (var extensions_1 = __values(extensions), extensions_1_1 = extensions_1.next(); !extensions_1_1.done; extensions_1_1 = extensions_1.next()) {
                var _d = __read(extensions_1_1.value, 3), tagName = _d[0], declaration = _d[1], identifierNode = _d[2];
                context.emitDefinitionResult({
                    tagName: tagName,
                    definitionNode: node,
                    identifierNode: identifierNode,
                    declarationNode: declaration
                });
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (extensions_1_1 && !extensions_1_1.done && (_b = extensions_1.return)) _b.call(extensions_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return;
    }
    node.forEachChild(function (child) {
        visitComponentDefinitions(child, context);
    });
}

/**
 * Visits and finds global events.
 * @param node
 * @param context
 */
function visitGlobalEvents(node, context) {
    var e_1, _a;
    var ts = context.ts;
    // declare global { interface HTMLElementEventMap  { "my-event": CustomEvent<string>; } }
    if (ts.isInterfaceDeclaration(node) && node.name.text === "HTMLElementEventMap") {
        var extensions = getInterfaceKeys(node, context);
        try {
            for (var extensions_1 = __values(extensions), extensions_1_1 = extensions_1.next(); !extensions_1_1.done; extensions_1_1 = extensions_1.next()) {
                var _b = __read(extensions_1_1.value, 1), eventName = _b[0];
                context.emitEvent({ type: { kind: tsSimpleType.SimpleTypeKind.ANY }, name: eventName, node: node });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (extensions_1_1 && !extensions_1_1.done && (_a = extensions_1.return)) _a.call(extensions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return;
    }
    node.forEachChild(function (child) {
        visitGlobalEvents(child, context);
    });
}

/**
 * Custom element flavor.
 * This is the base flavor and affects many other flavors because it finds properties and definitions.
 */
var CustomElementFlavor = /** @class */ (function () {
    function CustomElementFlavor() {
    }
    CustomElementFlavor.prototype.visitComponentDefinitions = function (node, context) {
        visitComponentDefinitions(node, context);
    };
    CustomElementFlavor.prototype.parseDeclarationMembers = function (node, context) {
        return parseDeclarationMembers(node, context);
    };
    CustomElementFlavor.prototype.parseDeclarationEvents = function (node, context) {
        return parseDeclarationEvents(node, context);
    };
    CustomElementFlavor.prototype.visitGlobalEvents = function (node, context) {
        visitGlobalEvents(node, context);
    };
    return CustomElementFlavor;
}());

function parseJsDocForNode(node, tagName, transform, context) {
    var ts = context.ts;
    var jsDoc = getJsDoc(node, ts);
    if (jsDoc != null && jsDoc.tags != null) {
        var items = jsDoc.tags
            .filter(function (tag) { return (Array.isArray(tagName) ? tagName : [tagName]).includes(tag.tag.toLowerCase()); })
            .map(function (tag) {
            var parsed = parseJsDocTagComment(tag);
            return transform(tag.node, parsed);
        })
            .filter(function (item) { return item != null; });
        if (items.length > 0) {
            context.emitContinue && context.emitContinue();
            return items;
        }
    }
    return undefined;
}

/**
 * Parses @cssprop | @cssproperty js doc annotations on interface/class-like nodes.
 * @param node
 * @param context
 */
function parseDeclarationCSSProps(node, context) {
    var ts = context.ts;
    if (ts.isInterfaceDeclaration(node) || ts.isClassDeclaration(node)) {
        return parseJsDocForNode(node, ["cssprop", "cssproperty", "cssvar", "cssvariable"], function (tagNode, parsed) {
            if (parsed.name != null) {
                return {
                    name: parsed.name,
                    jsDoc: parsed.comment != null ? { comment: parsed.comment } : undefined
                };
            }
        }, context);
    }
    return undefined;
}

/**
 * Parses @fires js doc annotations on interface/class-like nodes.
 * @param node
 * @param context
 */
function parseDeclarationEvents$1(node, context) {
    var ts = context.ts;
    if (ts.isInterfaceDeclaration(node) || ts.isClassDeclaration(node)) {
        return parseJsDocForNode(node, ["event", "fires", "emits"], function (tagNode, parsed) {
            if (parsed.name != null) {
                return {
                    name: parsed.name,
                    jsDoc: parsed.comment != null ? { comment: parsed.comment } : undefined,
                    type: (parsed.type && parseJsDocTypeString(parsed.type)) || { kind: tsSimpleType.SimpleTypeKind.ANY },
                    node: tagNode
                };
            }
        }, context);
    }
    return undefined;
}

/**
 * Parses @prop | @property js doc annotations on interface/class-like nodes.
 * @param node
 * @param context
 */
function parseDeclarationMembers$1(node, context) {
    var ts = context.ts;
    if (ts.isInterfaceDeclaration(node) || ts.isClassDeclaration(node)) {
        var properties = parseJsDocForNode(node, ["prop", "property"], function (tagNode, parsed) {
            if (parsed.name != null) {
                return {
                    kind: "property",
                    propName: parsed.name,
                    jsDoc: parsed.comment != null ? { comment: parsed.comment } : undefined,
                    type: (parsed.type && parseJsDocTypeString(parsed.type)) || { kind: tsSimpleType.SimpleTypeKind.ANY },
                    node: tagNode
                };
            }
        }, context);
        var attributes = parseJsDocForNode(node, ["attr", "attribute"], function (tagNode, parsed) {
            if (parsed.name != null) {
                return {
                    kind: "attribute",
                    attrName: parsed.name,
                    jsDoc: parsed.comment && { comment: parsed.comment },
                    type: (parsed.type && parseJsDocTypeString(parsed.type)) || { kind: tsSimpleType.SimpleTypeKind.ANY },
                    node: tagNode
                };
            }
        }, context);
        if (attributes != null || properties != null) {
            return __spread((attributes || []), (properties || []));
        }
    }
    return undefined;
}

/**
 * Parses @slot js doc annotations on interface/class-like nodes.
 * @param node
 * @param context
 */
function parseDeclarationSlots(node, context) {
    var ts = context.ts;
    if (ts.isInterfaceDeclaration(node) || ts.isClassDeclaration(node)) {
        return parseJsDocForNode(node, "slot", function (tagNode, parsed) {
            // Grab the type from jsdoc and use it to find permitted tag names
            // Example: @slot {"div"|"span"} myslot
            var permittedTagNameType = parsed.type == null ? undefined : parseJsDocTypeString(parsed.type);
            var permittedTagNames = (function () {
                if (permittedTagNameType == null) {
                    return undefined;
                }
                switch (permittedTagNameType.kind) {
                    case tsSimpleType.SimpleTypeKind.STRING_LITERAL:
                        return [permittedTagNameType.value];
                    case tsSimpleType.SimpleTypeKind.UNION:
                        return permittedTagNameType.types
                            .filter(function (type) { return type.kind === tsSimpleType.SimpleTypeKind.STRING_LITERAL; })
                            .map(function (type) { return type.value; });
                    default:
                        return undefined;
                }
            })();
            return {
                name: parsed.name,
                jsDoc: parsed.comment != null ? { comment: parsed.comment } : undefined,
                permittedTagNames: permittedTagNames
            };
        }, context);
    }
    return undefined;
}

/**
 * Parses @customElement js doc annotations on interface/class-like nodes and emits a definition.
 * @param node
 * @param context
 */
function visitComponentDefinitions$1(node, context) {
    var e_1, _a;
    var ts = context.ts;
    // /** @customElement my-element */ myClass extends HTMLElement { ... }
    if (ts.isInterfaceDeclaration(node) || ts.isClassDeclaration(node)) {
        var jsDoc = getJsDoc(node, ts);
        if (jsDoc != null && jsDoc.tags != null) {
            try {
                for (var _b = __values(jsDoc.tags), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var tag = _c.value;
                    if (["customelement", "element"].includes(tag.tag.toLowerCase())) {
                        context.emitDefinitionResult({
                            tagName: tag.comment || "",
                            identifierNode: tag.node,
                            declarationNode: node,
                            definitionNode: tag.node
                        });
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    }
    node.forEachChild(function (child) { return visitComponentDefinitions$1(child, context); });
}

/**
 * JsDoc Flavor.
 * This flavor only looks at jsdoc and continues the visiting flavors in children nodes after emitting members.
 */
var JsDocFlavor = /** @class */ (function () {
    function JsDocFlavor() {
    }
    JsDocFlavor.prototype.visitComponentDefinitions = function (node, context) {
        visitComponentDefinitions$1(node, context);
    };
    JsDocFlavor.prototype.parseDeclarationMembers = function (node, context) {
        return parseDeclarationMembers$1(node, context);
    };
    JsDocFlavor.prototype.parseDeclarationEvents = function (node, context) {
        return parseDeclarationEvents$1(node, context);
    };
    JsDocFlavor.prototype.parseDeclarationSlots = function (node, context) {
        return parseDeclarationSlots(node, context);
    };
    JsDocFlavor.prototype.parseDeclarationCSSProps = function (node, context) {
        return parseDeclarationCSSProps(node, context);
    };
    return JsDocFlavor;
}());

/**
 * According to {@link https://html.spec.whatwg.org/multipage/syntax.html#attributes-2}, the following Unicode characters are illegal in an attribute name
 * @type {RegExp}
 */
var ILLEGAL_UNICODE_CHARACTERS = /[\u0020\u0022\u0027\u003E\u002F\u003D]/g;
/**
 * According to {@link https://infra.spec.whatwg.org/#noncharacter},
 * a noncharacter is a codepoint that matches any of the given unicode characters
 * @type {RegExp}
 */
var NONCHARACTERS = /[\uFFFF\uFFFE\uFDD1\uFDD2\uFDD3\uFDD4\uFDD5\uFDD6\uFDD7\uFDD8\uFDD9\uFDDA\uFDDB\uFDDC\uFDDD\uFDDE\uFDDF\uFDE0\uFDE1\uFDE2\uFDE3\uFDE4\uFDE5\uFDE6\uFDE7\uFDE8\uFDE9\uFDEA\uFDEB\uFDEC\uFDED\uFDEE\uFDEF]/g;
/**
 * The HTML spec defines what are valid characters in an attribute name {@link https://html.spec.whatwg.org/multipage/syntax.html#attributes-2}.
 * This helper functions ensures that the given input conforms to those rules
 * @param {string} name
 * @return {string}
 */
function sanitizeAttributeName(name) {
    return name
        .toLowerCase()
        .replace(ILLEGAL_UNICODE_CHARACTERS, "")
        .replace(NONCHARACTERS, "");
}
/**
 * Returns true if the given input is a valid attribute name
 * @param {string} input
 * @return {boolean}
 */
function isValidAttributeName(input) {
    return sanitizeAttributeName(input) === input;
}

/**
 * Joins an array with a custom final splitter
 * @param items
 * @param splitter
 * @param finalSplitter
 */
function joinArray(items, splitter, finalSplitter) {
    if (splitter === void 0) { splitter = ", "; }
    if (finalSplitter === void 0) { finalSplitter = "or"; }
    return items.join(splitter).replace(/, ([^,]*)$/, " " + finalSplitter + " $1");
}
/**
 * Converts from camel case to snake case
 * @param str
 */
function camelToDashCase(str) {
    return str.replace(/[A-Z]/g, function (m) { return "-" + m.toLowerCase(); });
}

/**
 * Returns a potential lit element property decorator.
 * @param node
 * @param context
 */
function getLitElementPropertyDecorator(node, context) {
    if (node.decorators == null)
        return undefined;
    var ts = context.ts;
    // Find a decorator with "property" name.
    var decorator = node.decorators.find(function (decorator) {
        var expression = decorator.expression;
        return ts.isCallExpression(expression) && ts.isIdentifier(expression.expression) && expression.expression.text === "property";
    });
    return decorator != null && ts.isCallExpression(decorator.expression) ? decorator.expression : undefined;
}
/**
 * Returns a potential lit property decorator configuration.
 * @param node
 * @param context
 */
function getLitElementPropertyDecoratorConfig(node, context) {
    var ts = context.ts;
    // Get reference to a possible "@property" decorator.
    var decorator = getLitElementPropertyDecorator(node, context);
    if (decorator != null) {
        // Parse the first argument to the decorator which is the lit-property configuration.
        var configNode = decorator.arguments[0];
        return configNode != null && ts.isObjectLiteralExpression(configNode) ? getLitPropertyOptions(configNode, context) : {};
    }
    return undefined;
}
/**
 * Parses an object literal expression and returns a lit property configuration.
 * @param node
 * @param context
 */
function getLitPropertyOptions(node, context) {
    var ts = context.ts;
    // Build up the property configuration by looking at properties in the object literal expression
    return node.properties.reduce(function (config, property) {
        if (!ts.isPropertyAssignment(property))
            return config;
        var initializer = property.initializer;
        var kind = ts.isIdentifier(property.name) ? property.name.text : undefined;
        return parseLitPropertyOption({ kind: kind, initializer: initializer, config: config }, context);
    }, {});
}
function parseLitPropertyOption(_a, context) {
    var kind = _a.kind, initializer = _a.initializer, config = _a.config;
    var ts = context.ts, checker = context.checker;
    // noinspection DuplicateCaseLabelJS
    switch (kind) {
        case "converter": {
            return __assign(__assign({}, config), { hasConverter: true });
        }
        case "attribute": {
            var attribute = void 0;
            if (initializer.kind === ts.SyntaxKind.TrueKeyword) {
                attribute = true;
            }
            else if (initializer.kind === ts.SyntaxKind.FalseKeyword) {
                attribute = false;
            }
            else if (ts.isStringLiteral(initializer)) {
                attribute = initializer.text;
            }
            return __assign(__assign({}, config), { attribute: attribute, node: __assign(__assign({}, (config.node || {})), { attribute: initializer }) });
        }
        case "type": {
            var type = void 0;
            var value = ts.isIdentifier(initializer) ? initializer.text : undefined;
            switch (value) {
                case "String":
                case "StringConstructor":
                    type = { kind: tsSimpleType.SimpleTypeKind.STRING };
                    break;
                case "Number":
                case "NumberConstructor":
                    type = { kind: tsSimpleType.SimpleTypeKind.NUMBER };
                    break;
                case "Boolean":
                case "BooleanConstructor":
                    type = { kind: tsSimpleType.SimpleTypeKind.BOOLEAN };
                    break;
                case "Array":
                case "ArrayConstructor":
                    type = { kind: tsSimpleType.SimpleTypeKind.ARRAY, type: { kind: tsSimpleType.SimpleTypeKind.ANY } };
                    break;
                case "Object":
                case "ObjectConstructor":
                    type = { kind: tsSimpleType.SimpleTypeKind.OBJECT, members: [] };
                    break;
                default:
                    // This is an unknown type, so set the name as a string
                    type = initializer.getText();
                    break;
            }
            return __assign(__assign({}, config), { type: type, node: __assign(__assign({}, (config.node || {})), { type: initializer }) });
        }
        // Polymer specific field
        case "value": {
            return __assign(__assign({}, config), { default: resolveNodeValue(initializer, { ts: ts, checker: checker }) });
        }
    }
    return config;
}

/**
 * Parses lit-related declaration members.
 * This is primary by looking at the "@property" decorator and the "static get properties()".
 * @param node
 * @param context
 */
function parseDeclarationMembers$2(node, context) {
    var ts = context.ts;
    // static get properties() { return { myProp: {type: String} } }
    if (ts.isGetAccessor(node) && hasModifier(node, ts.SyntaxKind.StaticKeyword)) {
        var name_1 = node.name.getText();
        if (name_1 === "properties" && node.body != null) {
            var returnStatement = node.body.statements.find(ts.isReturnStatement.bind(ts));
            if (returnStatement != null) {
                return parseStaticProperties(returnStatement, context);
            }
        }
    }
    // @property({type: String}) myProp = "hello";
    else if ((ts.isSetAccessorDeclaration(node) || ts.isPropertyDeclaration(node) || ts.isPropertySignature(node)) && hasPublicSetter(node, ts)) {
        return parsePropertyDecorator(node, context);
    }
}
/**
 * Visits a lit property decorator and returns members based on it.
 * @param node
 * @param context
 */
function parsePropertyDecorator(node, context) {
    var ts = context.ts, checker = context.checker;
    // Parse the content of a possible lit "@property" decorator.
    var litConfig = getLitElementPropertyDecoratorConfig(node, context);
    if (litConfig != null) {
        var propName = node.name.getText();
        var propType = checker.getTypeAtLocation(node);
        var simplePropType = tsSimpleType.toSimpleType(propType, checker);
        var inJavascriptFile = node.getSourceFile().fileName.endsWith(".js");
        var type = inJavascriptFile && typeof litConfig.type === "object" && litConfig.type.kind === tsSimpleType.SimpleTypeKind.ANY ? litConfig.type : propType;
        // Don't emit anything if "attribute" is false.
        // "Custom Element Flavor" takes care of parsing the property then.
        if (litConfig.attribute === false) {
            return;
        }
        // Look at diagnostics if on.
        if (context.config.diagnostics) {
            validateLitPropertyConfig(getLitElementPropertyDecorator(node, context) || node, litConfig, {
                propName: propName,
                simplePropType: simplePropType
            }, context);
        }
        // Get the attribute based on the configuration
        var attrName = getLitAttributeName(propName, litConfig, context);
        // Find the default value for this property
        var def = "initializer" in node && node.initializer != null ? resolveNodeValue(node.initializer, context) : undefined;
        // Find our if the property/attribute is required
        var required = ("initializer" in node && isPropertyRequired(node, context.checker)) || undefined;
        var jsDoc = getJsDoc(node, ts);
        // Emit a property with "attrName"
        return [
            {
                kind: "property",
                propName: propName,
                attrName: attrName,
                type: type,
                node: node,
                default: def !== undefined ? def : litConfig.default,
                required: required,
                jsDoc: jsDoc
            }
        ];
    }
    return undefined;
}
/**
 * Returns if we are in a Polymer context.
 * @param context
 */
function inPolymerFlavorContext(context) {
    var inherits = context.features != null ? context.features.getInherits() : [];
    return inherits.includes("PolymerElement") || inherits.includes("Polymer.Element");
}
/**
 * Returns an attribute name based on a property name and a lit-configuration
 * @param propName
 * @param litConfig
 * @param context
 */
function getLitAttributeName(propName, litConfig, context) {
    // Get the attribute name either by looking at "{attribute: ...}" or just taking the property name.
    var attrName = typeof litConfig.attribute === "string" ? litConfig.attribute : propName;
    if (inPolymerFlavorContext(context)) {
        // From the documentation: https://polymer-library.polymer-project.org/3.0/docs/devguide/properties#attribute-reflection
        attrName = camelToDashCase(attrName).toLowerCase();
    }
    return attrName;
}
/**
 * Visits static properties
 * static get properties() { return { myProp: {type: String, attribute: "my-attr"} } }
 * @param returnStatement
 * @param context
 */
function parseStaticProperties(returnStatement, context) {
    var e_1, _a;
    var ts = context.ts;
    var members = [];
    if (returnStatement.expression != null && ts.isObjectLiteralExpression(returnStatement.expression)) {
        var isPolymerFlavor = inPolymerFlavorContext(context);
        try {
            // Each property in the object literal expression corresponds to a class field.
            for (var _b = __values(returnStatement.expression.properties), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propNode = _c.value;
                // Get propName
                var propName = propNode.name != null && ts.isIdentifier(propNode.name) ? propNode.name.text : undefined;
                if (propName == null || !isPropNamePublic(propName)) {
                    continue;
                }
                // Parse the lit property config for this property
                // Treat non-object-literal-expressions like the "type" (to support Polymer specific syntax)
                var litConfig = ts.isPropertyAssignment(propNode)
                    ? ts.isObjectLiteralExpression(propNode.initializer)
                        ? getLitPropertyOptions(propNode.initializer, context)
                        : isPolymerFlavor
                            ? parseLitPropertyOption({
                                kind: "type",
                                initializer: propNode.initializer,
                                config: {}
                            }, context)
                            : {}
                    : {};
                // Get attrName based on the litConfig
                var attrName = getLitAttributeName(propName, litConfig, context);
                // Get more metadata
                var jsDoc = getJsDoc(propNode, ts);
                var type = (jsDoc && getJsDocType(jsDoc)) || (typeof litConfig.type === "object" && litConfig.type) || { kind: tsSimpleType.SimpleTypeKind.ANY };
                var emitAttribute = litConfig.attribute !== false;
                // Look at diagnostics is on.
                if (context.config.diagnostics) {
                    validateLitPropertyConfig(propNode, litConfig, {
                        propName: propName,
                        simplePropType: { kind: tsSimpleType.SimpleTypeKind.ANY }
                    }, context);
                }
                // Emit either the attribute or the property
                members.push({
                    kind: "property",
                    type: type,
                    propName: propName,
                    attrName: emitAttribute ? attrName : undefined,
                    jsDoc: jsDoc,
                    node: propNode,
                    default: litConfig.default
                });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    return members;
}
/**
 * Returns a string, that can be used in a lit @property decorator for the type key, representing the simple type kind.
 * @param simpleTypeKind
 */
function toLitPropertyTypeString(simpleTypeKind) {
    switch (simpleTypeKind) {
        case tsSimpleType.SimpleTypeKind.STRING:
            return "String";
        case tsSimpleType.SimpleTypeKind.NUMBER:
            return "Number";
        case tsSimpleType.SimpleTypeKind.BOOLEAN:
            return "Boolean";
        case tsSimpleType.SimpleTypeKind.ARRAY:
            return "Array";
        case tsSimpleType.SimpleTypeKind.OBJECT:
            return "Object";
        default:
            return "";
    }
}
/**
 * Runs through a lit configuration and validates against the "simplePropType".
 * Emits diagnostics through the context.
 * @param node
 * @param litConfig
 * @param propName
 * @param simplePropType
 * @param context
 */
function validateLitPropertyConfig(node, litConfig, _a, context) {
    var _b;
    var propName = _a.propName, simplePropType = _a.simplePropType;
    if (typeof litConfig.attribute === "string") {
        if (!isValidAttributeName(litConfig.attribute)) {
            context.emitDiagnostics({
                node: (litConfig.node && litConfig.node.attribute) || node,
                severity: "error",
                message: "Invalid attribute name '" + litConfig.attribute + "'"
            });
        }
    }
    // Check if "type" is one of the built in default type converter hint
    if (typeof litConfig.type === "string" && !litConfig.hasConverter) {
        context.emitDiagnostics({
            node: (litConfig.node && litConfig.node.type) || node,
            message: "'" + litConfig.type + "' is not a valid type for the default converter. Have you considered {attribute: false} instead?",
            severity: "warning"
        });
        return;
    }
    // Don't continue if we don't know the property type (eg if we are in a js file)
    // Don't continue if this property has a custom converter (because then we don't know how the value will be converted)
    if (simplePropType == null || litConfig.hasConverter || typeof litConfig.type === "string") {
        return;
    }
    // Test assignments to all possible type kinds
    var isAssignableTo = (_b = {},
        _b[tsSimpleType.SimpleTypeKind.STRING] = tsSimpleType.isAssignableToSimpleTypeKind(simplePropType, [tsSimpleType.SimpleTypeKind.STRING, tsSimpleType.SimpleTypeKind.STRING_LITERAL], { op: "or" }),
        _b[tsSimpleType.SimpleTypeKind.NUMBER] = tsSimpleType.isAssignableToSimpleTypeKind(simplePropType, [tsSimpleType.SimpleTypeKind.NUMBER, tsSimpleType.SimpleTypeKind.NUMBER_LITERAL], { op: "or" }),
        _b[tsSimpleType.SimpleTypeKind.BOOLEAN] = tsSimpleType.isAssignableToSimpleTypeKind(simplePropType, [tsSimpleType.SimpleTypeKind.BOOLEAN, tsSimpleType.SimpleTypeKind.BOOLEAN_LITERAL], { op: "or" }),
        _b[tsSimpleType.SimpleTypeKind.ARRAY] = tsSimpleType.isAssignableToSimpleTypeKind(simplePropType, [tsSimpleType.SimpleTypeKind.ARRAY, tsSimpleType.SimpleTypeKind.TUPLE], { op: "or" }),
        _b[tsSimpleType.SimpleTypeKind.OBJECT] = tsSimpleType.isAssignableToSimpleTypeKind(simplePropType, [tsSimpleType.SimpleTypeKind.OBJECT, tsSimpleType.SimpleTypeKind.INTERFACE], {
            op: "or"
        }),
        _b[tsSimpleType.SimpleTypeKind.ANY] = tsSimpleType.isAssignableToSimpleTypeKind(simplePropType, tsSimpleType.SimpleTypeKind.ANY),
        _b);
    // Collect type kinds that can be used in as "type" in the @property decorator
    var acceptedTypeKinds = Object.entries(isAssignableTo)
        .filter(function (_a) {
        var _b = __read(_a, 2), assignable = _b[1];
        return assignable;
    })
        .map(function (_a) {
        var _b = __read(_a, 1), kind = _b[0];
        return kind;
    })
        .filter(function (kind) { return kind !== tsSimpleType.SimpleTypeKind.ANY; });
    // Test the @property type against the actual type if a type has been provided
    if (litConfig.type != null) {
        // Report error if the @property type is not assignable to the actual type
        if (isAssignableTo[litConfig.type.kind] === false && isAssignableTo[tsSimpleType.SimpleTypeKind.ANY] === false) {
            // Suggest what to use instead
            if (acceptedTypeKinds.length >= 1) {
                var potentialKindText = joinArray(acceptedTypeKinds.map(function (kind) { return "'" + toLitPropertyTypeString(kind) + "'"; }), ", ", "or");
                context.emitDiagnostics({
                    node: (litConfig.node && litConfig.node.type) || node,
                    message: "@property type should be " + potentialKindText + " instead of '" + toLitPropertyTypeString(litConfig.type.kind) + "'",
                    severity: "warning"
                });
            }
            // If no suggesting can be provided, report that they are not assignable
            // The OBJECT @property type is an escape from this error
            else if (litConfig.type.kind !== tsSimpleType.SimpleTypeKind.OBJECT) {
                context.emitDiagnostics({
                    node: (litConfig.node && litConfig.node.type) || node,
                    message: "@property type '" + tsSimpleType.toTypeString(litConfig.type) + "' is not assignable to the actual type '" + tsSimpleType.toTypeString(simplePropType) + "'",
                    severity: "warning"
                });
            }
        }
    }
    // If no type has been specified, suggest what to use as the @property type
    else {
        if (!litConfig.hasConverter && litConfig.attribute !== false) {
            // Don't do anything if there are multiple possibilities for a type.
            if (isAssignableTo[tsSimpleType.SimpleTypeKind.ANY]) ;
            // Don't report errors because String conversion is default
            else if (isAssignableTo[tsSimpleType.SimpleTypeKind.STRING]) ;
            // Suggest what to use instead if there are multiple accepted @property types for this property
            else if (acceptedTypeKinds.length > 0) {
                // Suggest types to use and include "{attribute: false}" if the @property type is ARRAY or OBJECT
                var acceptedTypeText = joinArray(__spread(acceptedTypeKinds.map(function (kind) { return "'{type: " + toLitPropertyTypeString(kind) + "}'"; }), (isAssignableTo[tsSimpleType.SimpleTypeKind.ARRAY] || isAssignableTo[tsSimpleType.SimpleTypeKind.OBJECT] ? ["'{attribute: false}'"] : [])), ", ", "or");
                context.emitDiagnostics({
                    node: node,
                    severity: "warning",
                    message: "Missing " + acceptedTypeText + " on @property decorator for '" + propName + "'"
                });
            }
            else {
                context.emitDiagnostics({
                    node: node,
                    severity: "warning",
                    message: "The built in converter doesn't handle the property type '" + tsSimpleType.toTypeString(simplePropType) + "'. Please add '{attribute: false}' on @property decorator for '" + propName + "'"
                });
            }
        }
    }
    /*if (litConfig.attribute !== false && !isAssignableToPrimitiveType(simplePropType)) {
     context.emitDiagnostics({
     node,
     severity: "warning",
     message: `You need to add '{attribute: false}' to @property decorator for '${propName}' because '${toTypeString(simplePropType)}' type is not a primitive`
     });
     }*/
}

/**
 * Visits lit-element related definitions.
 * Specifically it finds the usage of the @customElement decorator.
 * @param node
 * @param context
 */
function visitComponentDefinitions$2(node, context) {
    var e_1, _a;
    var ts = context.ts, checker = context.checker;
    // @customElement("my-element")
    if (ts.isClassDeclaration(node)) {
        try {
            for (var _b = __values(node.decorators || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var decorator = _c.value;
                var callExpression = decorator.expression;
                if (ts.isCallExpression(callExpression) && ts.isIdentifier(callExpression.expression)) {
                    var decoratorIdentifierName = callExpression.expression.escapedText;
                    if (decoratorIdentifierName === "customElement") {
                        // Resolve the value of the first argument. This is the tag name.
                        var identifierNode = callExpression.arguments[0];
                        var tagName = resolveNodeValue(identifierNode, { ts: ts, checker: checker });
                        if (typeof tagName === "string") {
                            context.emitDefinitionResult({
                                tagName: tagName,
                                identifierNode: identifierNode,
                                definitionNode: node,
                                declarationNode: node
                            });
                        }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return;
    }
    node.forEachChild(function (child) {
        visitComponentDefinitions$2(child, context);
    });
}

var LitElementFlavor = /** @class */ (function () {
    function LitElementFlavor() {
    }
    LitElementFlavor.prototype.visitComponentDefinitions = function (node, context) {
        visitComponentDefinitions$2(node, context);
    };
    LitElementFlavor.prototype.parseDeclarationMembers = function (node, context) {
        return parseDeclarationMembers$2(node, context);
    };
    return LitElementFlavor;
}());

/**
 * Parses declaration members. This function is made to be used only on interfaces declared
 * using the "StencilIntrinsicElements" global typing interface because this interface only has attributes.
 * @param node
 * @param context
 */
function parseDeclarationMembers$3(node, context) {
    var ts = context.ts, checker = context.checker;
    // Don't visit interfaces in "stencil.core.d.ts" because it's basically a copy of HTMLElement which we don't want to include.
    if (node.getSourceFile().fileName.endsWith("stencil.core.d.ts") && !context.config.analyzeLibDom) {
        return undefined;
    }
    // class { myAttr: string; }
    if (ts.isPropertyDeclaration(node) || ts.isPropertySignature(node) || ts.isConditionalExpression(node)) {
        var name_1 = ts.isConditionalExpression(node) ? node.condition : node.name;
        if (ts.isIdentifier(name_1) || ts.isStringLiteralLike(name_1)) {
            return [
                {
                    kind: "attribute",
                    attrName: name_1.text,
                    type: checker.getTypeAtLocation(node),
                    node: node
                }
            ];
        }
    }
}

/**
 * Visits stencil like component definitions.
 * Right now it only parses "StencilIntrinsicElements" and emits attributes for this interface
 * because "custom element" flavor parses the property related version of the element.
 * @param node
 * @param context
 */
function visitComponentDefinitions$3(node, context) {
    var e_1, _a;
    var ts = context.ts;
    if (ts.isInterfaceDeclaration(node)) {
        // interface HTMLElementTagNameMap { "my-button": MyButton; }
        if (["StencilIntrinsicElements"].includes(node.name.text)) {
            var extensions = getInterfaceKeys(node, context);
            try {
                for (var extensions_1 = __values(extensions), extensions_1_1 = extensions_1.next(); !extensions_1_1.done; extensions_1_1 = extensions_1.next()) {
                    var _b = __read(extensions_1_1.value, 3), tagName = _b[0], declaration = _b[1], identifierNode = _b[2];
                    // Emit a definition result and set an explicit declaration handler
                    context.emitDefinitionResult({
                        tagName: tagName,
                        identifierNode: identifierNode,
                        definitionNode: node,
                        declarationNode: declaration,
                        declarationHandler: parseDeclarationMembers$3
                    });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (extensions_1_1 && !extensions_1_1.done && (_a = extensions_1.return)) _a.call(extensions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return;
    }
    node.forEachChild(function (child) {
        visitComponentDefinitions$3(child, context);
    });
}

/**
 * Stencil flavor
 * This flavor finds and parses stencil related components.
 */
var StencilFlavor = /** @class */ (function () {
    function StencilFlavor() {
    }
    StencilFlavor.prototype.visitComponentDefinitions = function (node, context) {
        visitComponentDefinitions$3(node, context);
    };
    return StencilFlavor;
}());

/**
 * Returns true if the given input is a valid custom element name
 * @param {string} input
 * @return {boolean}
 */
function isValidCustomElementName(input) {
    return input.includes("-");
}

/**
 * Run through all components expanding them with the associated jsdoc.
 * @param members
 */
function expandMembersFromJsDoc(members) {
    return members.map(expandMemberFromJsDoc);
}
/**
 * Expand a single member with qualities from the associated jsdoc.
 * @param member
 */
function expandMemberFromJsDoc(member) {
    // Return right away if the member doesn't have jsdoc
    if (member.jsDoc == null || member.jsDoc.tags == null)
        return member;
    var newMember = __assign({}, member);
    // Check "@deprecated"
    var deprecatedTag = member.jsDoc.tags.find(function (t) { return t.tag === "deprecated"; });
    if (deprecatedTag != null) {
        newMember.deprecated = deprecatedTag.comment || true;
    }
    // Check "@prop {Number} myProp - My comment"
    if (newMember.kind === "property" && newMember.attrName == null) {
        var attrNameTag = member.jsDoc.tags.find(function (t) { return ["attr", "attribute"].includes(t.tag); });
        if (attrNameTag != null) {
            newMember.attrName = parseJsDocTagComment(attrNameTag).name || newMember.propName;
        }
    }
    // Check "@required" and "@optional"
    if (newMember.kind === "attribute" || newMember.kind === "property") {
        if (member.jsDoc.tags.find(function (t) { return t.tag === "optional"; }) != null) {
            newMember.required = false;
        }
        if (member.jsDoc.tags.find(function (t) { return t.tag === "required"; }) != null) {
            newMember.required = true;
        }
    }
    return newMember;
}
/**
 * Expand a component declaration with qualities from associated jsdoc
 * @param declaration
 */
function expandDeclarationFromJsDoc(declaration) {
    if (declaration.jsDoc == null || declaration.jsDoc.tags == null)
        return declaration;
    var newDeclaration = __assign({}, declaration);
    // Check "@deprecated"
    var deprecatedTag = declaration.jsDoc.tags.find(function (t) { return t.tag === "deprecated"; });
    if (deprecatedTag != null) {
        newDeclaration.deprecated = deprecatedTag.comment || true;
    }
    return newDeclaration;
}

/**
 * Merge jsdoc with a "main" jsdoc.
 * The main jsdoc keeps its comment.
 * The inherited js docs only extend with annotations.
 * @param mainJsDoc
 * @param inheritedJsDocs
 */
function mergeJsDocs(mainJsDoc, inheritedJsDocs) {
    var jsDoc = inheritedJsDocs.reduce(function (jsDoc, extendJsDoc) {
        if (extendJsDoc == null)
            return jsDoc;
        return __assign(__assign({}, jsDoc), { node: jsDoc.node, tags: __spread((jsDoc.tags || []), (extendJsDoc.tags || [])) });
    }, mainJsDoc || {});
    if (jsDoc.comment == null && (jsDoc.tags == null || jsDoc.tags.length === 0))
        return undefined;
    return jsDoc;
}

/**
 * Merges multiple component declarations.
 * @param declarations
 * @param context
 */
function mergeDeclarations(declarations, context) {
    // Return right away if there is only 1 declaration.
    if (declarations.length === 1)
        return declarations[0];
    // Collect all items from all declarations.
    var members = declarations.map(function (dec) { return dec.members; }).reduce(function (acc, members) { return __spread(acc, members); }, []);
    var events = declarations.map(function (dec) { return dec.events; }).reduce(function (acc, events) { return __spread(acc, events); }, []);
    var slots = declarations.map(function (dec) { return dec.slots; }).reduce(function (acc, slots) { return __spread(acc, slots); }, []);
    var cssProps = declarations.map(function (dec) { return dec.cssProperties; }).reduce(function (acc, cssProps) { return __spread(acc, cssProps); }, []);
    // Merge all items
    var mergedJsDoc = mergeJsDocs(declarations[0].jsDoc, declarations.slice(1).map(function (dec) { return dec.jsDoc; }));
    var mergedMembers = mergeMembers(members, context);
    var mergedSlots = mergeSlots(slots);
    var mergedEvents = mergeEvents(events);
    var mergedCSSProps = mergeCSSProps(cssProps);
    return __assign(__assign({}, declarations[0]), { jsDoc: mergedJsDoc, members: mergedMembers, slots: mergedSlots, events: mergedEvents, cssProperties: mergedCSSProps });
}
/**
 * Merges slots
 * @param slots
 */
function mergeSlots(slots) {
    return nameMerge(slots, "last");
}
/**
 * Merges events
 * @param events
 */
function mergeEvents(events) {
    return nameMerge(events, "last");
}
/**
 * Merges css props
 * @param cssProps
 */
function mergeCSSProps(cssProps) {
    return nameMerge(cssProps, "last");
}
/**
 * Merges based on a name and a direction.
 * "first": Only keep the first found item.
 * "last": Only keep the last found item.
 * This function always prefers one of the entries' jsDoc if defined
 * @param entries
 * @param direction
 */
function nameMerge(entries, direction) {
    var e_1, _a;
    if (direction === "last")
        entries = entries.reverse();
    var merged = new Map();
    try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
            var entry = entries_1_1.value;
            var existing = merged.get(entry.name || "");
            if (existing == null) {
                merged.set(entry.name || "", entry);
            }
            else if (existing.jsDoc == null && entry.jsDoc != null) {
                merged.set(entry.name || "", __assign(__assign({}, existing), { jsDoc: entry.jsDoc }));
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return Array.from(merged.values());
}
/**
 * Merges all members in the list of members.
 * @param members
 * @param context
 */
function mergeMembers(members, context) {
    var e_2, _a;
    var mergedMembers = [];
    var _loop_1 = function (member) {
        // Find a member that can be merged
        var existing = findMemberToMerge(mergedMembers, member);
        if (existing != null) {
            // Remove the item from the list and add the merged member
            mergedMembers.splice(mergedMembers.findIndex(function (m) { return m === existing; }), 1);
            var mergedMember_1 = mergeMember(existing, member, context.checker);
            mergedMembers.push(mergedMember_1);
            // If we are merging into a property we may need to remove a corresponding attribute if present, because it's not represented from the property.
            if (mergedMember_1.kind === "property" && "attrName" in mergedMember_1) {
                var indexWithAttrName = mergedMembers.findIndex(function (m) { return m.kind === "attribute" && m.attrName === mergedMember_1.attrName; });
                if (indexWithAttrName >= 0) {
                    mergedMembers.splice(indexWithAttrName, 1);
                }
            }
        }
        else {
            mergedMembers.push(member);
        }
    };
    try {
        // Loop through all members adding merged members to "mergedMembers"
        for (var members_1 = __values(members), members_1_1 = members_1.next(); !members_1_1.done; members_1_1 = members_1.next()) {
            var member = members_1_1.value;
            _loop_1(member);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (members_1_1 && !members_1_1.done && (_a = members_1.return)) _a.call(members_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return mergedMembers;
}
/**
 * Returns a member that can be merged with "similar".
 * @param members
 * @param similar
 */
function findMemberToMerge(members, similar) {
    if (similar.kind === "method")
        return undefined;
    // Merges attributes and properties based on the lowercased version of the name.
    var attrName = (similar.kind === "attribute" && similar.attrName.toLowerCase()) || undefined;
    var propName = (similar.kind === "property" && similar.propName.toLowerCase()) || undefined;
    // Return a member that matches either attrName or propName
    return members.find(function (member) {
        switch (member.kind) {
            case "attribute":
                return [attrName, propName].includes(member.attrName.toLowerCase());
            case "property":
                // If the member has an attrName compare it to the "attrName" of "similar"
                return ([attrName, propName].includes(member.propName.toLowerCase()) ||
                    (member.attrName != null ? member.attrName.toLowerCase() === attrName : false));
        }
        return false;
    });
}
/**
 * Merges two members
 * @param existing
 * @param newest
 * @param checker
 */
function mergeMember(existing, newest, checker) {
    switch (existing.kind) {
        case "property":
            switch (newest.kind) {
                case "property":
                    return mergeMemberIntoMember(existing, newest, checker);
                case "attribute":
                    return mergeAttrIntoProp(existing, newest, checker);
            }
            break;
        case "attribute":
            switch (newest.kind) {
                case "property":
                    return mergeAttrIntoProp(newest, existing, checker);
                case "attribute":
                    return mergeMemberIntoMember(existing, newest, checker);
            }
            break;
    }
    return existing;
}
/**
 * Merges an attribute into a property.
 * This operation prioritizes "attribute".
 * @param prop
 * @param attr
 * @param checker
 */
function mergeAttrIntoProp(prop, attr, checker) {
    return __assign(__assign({}, prop), { type: mergeTypes(prop.type, attr.type, checker), default: attr.default || prop.default, required: attr.required || prop.required, jsDoc: attr.jsDoc || prop.jsDoc, attrName: attr.attrName });
}
/**
 * Merges to members of the same kind into each other.
 * This operation basically merged their types and prioritizes "b".
 * @param a
 * @param b
 * @param checker
 */
function mergeMemberIntoMember(a, b, checker) {
    return __assign(__assign({}, b), { attrName: a.attrName || b.attrName, type: mergeTypes(a.type, b.type, checker) });
}
/**
 * Merges two types into each other.
 * This operation prioritizes "typeB" and returns "typeA" only if "typeB" is ANY and "typeA" is not ANY.
 * @param typeA
 * @param typeB
 * @param checker
 */
function mergeTypes(typeA, typeB, checker) {
    var simpleTypeB = tsSimpleType.isSimpleType(typeB) ? typeB : tsSimpleType.toSimpleType(typeB, checker);
    // If type B isn't assignable to "ANY", return it!
    if (!tsSimpleType.isAssignableToSimpleTypeKind(simpleTypeB, tsSimpleType.SimpleTypeKind.ANY)) {
        return typeB;
    }
    // Else if type A isn't assignable to "ANY" return it
    else if (!tsSimpleType.isAssignableToSimpleTypeKind(typeA, tsSimpleType.SimpleTypeKind.ANY, checker)) {
        return typeA;
    }
    // Else return "typeB"
    return typeB;
}

/**
 * Parses a component declaration using flavors.
 * @param declarationNode
 * @param flavors
 * @param context
 */
function parseComponentDeclaration(declarationNode, flavors, context) {
    var slots = [];
    var members = [];
    var events = [];
    var cssProps = [];
    var inherits = new Set();
    var inheritNodes = new Set();
    // Visit the declaration node using flavors.
    visitComponentDeclaration(declarationNode, flavors, __assign(__assign({}, context), { declarationNode: declarationNode, features: {
            getCSSProps: function () {
                return cssProps;
            },
            getEvents: function () {
                return events;
            },
            getInheritNodes: function () {
                return Array.from(inheritNodes);
            },
            getInherits: function () {
                return Array.from(inherits);
            },
            getMembers: function () {
                return members;
            },
            getSlots: function () {
                return slots;
            }
        }, emitMembers: function (newMembers) {
            members.push.apply(members, __spread(newMembers));
        },
        emitInheritNode: function (node) {
            inheritNodes.add(node);
        },
        emitCSSProps: function (newCSSProps) {
            cssProps.push.apply(cssProps, __spread(newCSSProps));
        },
        emitEvents: function (newEvents) {
            events.push.apply(events, __spread(newEvents));
        },
        emitSlots: function (newSlots) {
            slots.push.apply(slots, __spread(newSlots));
        },
        emitInherit: function (name) {
            inherits.add(name);
        } }));
    // Merge all jsdoc tags using inherited nodes.
    var mainJsDoc = isDeclarationExcluded(declarationNode, context) ? undefined : getJsDoc(declarationNode, context.ts);
    var inheritedJsDocs = Array.from(inheritNodes.values())
        .filter(function (node) { return !isDeclarationExcluded(node, context); })
        .map(function (n) { return getJsDoc(n, context.ts); });
    var jsDoc = mergeJsDocs(mainJsDoc, inheritedJsDocs);
    // Expand members using jsdoc annotations and merge all members.
    var mergedMembers = mergeMembers(expandMembersFromJsDoc(members), context);
    // Merge slots, events and css properties
    var mergedSlots = mergeSlots(slots);
    var mergedEvents = mergeEvents(events);
    var mergedCSSProps = mergeCSSProps(cssProps);
    var className = (context.ts.isClassDeclaration(declarationNode) || context.ts.isInterfaceDeclaration(declarationNode)) && declarationNode.name != null
        ? declarationNode.name.text
        : undefined;
    return {
        node: declarationNode,
        members: mergedMembers,
        slots: mergedSlots,
        events: mergedEvents,
        cssProperties: mergedCSSProps,
        inheritNodes: Array.from(inheritNodes.values()),
        inherits: Array.from(inherits.values()),
        className: className,
        jsDoc: jsDoc
    };
}
/**
 * Function that tests if this declaration is excluded based on the configuration.
 * @param node
 * @param context
 */
function isDeclarationExcluded(node, context) {
    if (!context.ts.isClassLike(node) && !context.ts.isInterfaceDeclaration(node))
        return false;
    if (context.config.excludedDeclarationNames == null)
        return false;
    var name = (node.name != null && node.name.text) || "";
    // Test if the name is excluded
    return context.config.excludedDeclarationNames.includes(name);
}
/**
 * Visit a declaration and emits members through the context.
 * @param node
 * @param flavors
 * @param context
 */
function visitComponentDeclaration(node, flavors, context) {
    if (node == null)
        return [];
    var ts = context.ts;
    // Skip visiting it's children if this name is excluded
    if (isDeclarationExcluded(node, context)) {
        return;
    }
    if (ts.isClassLike(node) || ts.isInterfaceDeclaration(node)) {
        // Visit inherited nodes
        visitInheritedComponentDeclarations(node, flavors, context);
    }
    // By default each flavor stops the parsing if it finds anything.
    // However each flavor has the ability to continue the recursion.
    // Emit members
    var membersResult = executeFirstFlavor(flavors, "parseDeclarationMembers", node, context);
    if (membersResult != null) {
        context.emitMembers(membersResult.result);
        if (!membersResult.shouldContinue)
            return;
    }
    // Emit events
    var eventsResult = executeFirstFlavor(flavors, "parseDeclarationEvents", node, context);
    if (eventsResult != null) {
        context.emitEvents(eventsResult.result);
        if (!eventsResult.shouldContinue)
            return;
    }
    // Emit css properties
    var cssPropertiesResult = executeFirstFlavor(flavors, "parseDeclarationCSSProps", node, context);
    if (cssPropertiesResult != null) {
        context.emitCSSProps(cssPropertiesResult.result);
        if (!cssPropertiesResult.shouldContinue)
            return;
    }
    // Emit slots
    var slotsResult = executeFirstFlavor(flavors, "parseDeclarationSlots", node, context);
    if (slotsResult != null) {
        context.emitSlots(slotsResult.result);
        if (!slotsResult.shouldContinue)
            return;
    }
    // Visit child nodes
    node.forEachChild(function (child) {
        visitComponentDeclaration(child, flavors, context);
    });
}
/**
 * This function call each flavor on a node until a flavor emits a result.
 * Each flavor has the ability to emit a "continue" instruction.
 * @param flavors
 * @param key
 * @param node
 * @param context
 */
function executeFirstFlavor(flavors, key, node, context) {
    var e_1, _a;
    var _loop_1 = function (flavor) {
        var func = flavor[key];
        if (func == null)
            return "continue";
        // Save a "continue" flag if necessary
        var shouldContinue = false;
        var result = func(node, __assign(__assign({}, context), { emitContinue: function () {
                shouldContinue = true;
            } }));
        // Return a result if not undefined
        if (result != null) {
            return { value: { result: result, shouldContinue: shouldContinue } };
        }
    };
    try {
        // Loop through each flavor
        for (var flavors_1 = __values(flavors), flavors_1_1 = flavors_1.next(); !flavors_1_1.done; flavors_1_1 = flavors_1.next()) {
            var flavor = flavors_1_1.value;
            var state_1 = _loop_1(flavor);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (flavors_1_1 && !flavors_1_1.done && (_a = flavors_1.return)) _a.call(flavors_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return undefined;
}
/**
 * Visits and emit declaration members in each interface/class-like inherited node.
 * @param node
 * @param flavors
 * @param context
 */
function visitInheritedComponentDeclarations(node, flavors, context) {
    var e_2, _a, e_3, _b, e_4, _c;
    var ts = context.ts;
    /*function go (n: Type) {
     if ("instantiations" in t) {
     const tt = t as ConditionalRoot;
     console.log(`ConditionalRoot: instantiations`);
     tt.instantiations!.forEach((value, key) => {
     console.log(key, context.checker.typeToString(value));
     go(value);
     });
     }
     }

     const t = context.checker.getTypeAtLocation(node);
     console.log("Type: ", context.checker.typeToString(t));
     go(t);*/
    if (node.heritageClauses != null) {
        try {
            for (var _d = __values(node.heritageClauses || []), _e = _d.next(); !_e.done; _e = _d.next()) {
                var heritage = _e.value;
                // class Test implements MyBase
                // Don't visit interfaces if we are looking at a class, because the class already declares all things from the interface
                if (ts.isClassLike(node) && heritage.token === ts.SyntaxKind.ImplementsKeyword) {
                    try {
                        for (var _f = (e_3 = void 0, __values(heritage.types)), _g = _f.next(); !_g.done; _g = _f.next()) {
                            var type = _g.value;
                            context.emitInheritNode(type.expression);
                            context.emitInherit(type.expression.getText());
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                    continue;
                }
                try {
                    // [extends|implements] MyBase
                    for (var _h = (e_4 = void 0, __values(heritage.types)), _j = _h.next(); !_j.done; _j = _h.next()) {
                        var type = _j.value;
                        resolveAndExtendHeritage(type.expression, flavors, context);
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
}
function resolveAndExtendHeritage(node, flavors, context) {
    var e_5, _a, e_6, _b, e_7, _c;
    var ts = context.ts;
    // Emit extends name
    context.emitInherit(node.getText());
    if (ts.isCallExpression(node)) {
        // Mixins
        var identifier = node.expression, args = node.arguments;
        try {
            // Extend classes given to the mixin
            // Example: class MyElement extends MyMixin(MyBase) --> MyBase
            // Example: class MyElement extends MyMixin(MyBase1, MyBase2) --> MyBase1, MyBase2
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var argument = args_1_1.value;
                resolveAndExtendHeritage(argument, flavors, context);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        // Resolve and traverse the mixin function
        // Example: class MyElement extends MyMixin(MyBase) --> MyMixin
        if (identifier != null) {
            var declarations = resolveDeclarations(identifier, context);
            try {
                for (var declarations_1 = __values(declarations), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {
                    var declaration = declarations_1_1.value;
                    // Extend right away if the node is a class declaration
                    if (ts.isClassLike(declaration)) {
                        extendWithDeclarationNode(declaration, flavors, context);
                        return;
                    }
                    // Else find the first class declaration in the block
                    // Note that we don't look for a return statement because this would complicate things
                    var clzDecl = findChild(declaration, ts.isClassLike);
                    if (clzDecl != null) {
                        extendWithDeclarationNode(clzDecl, flavors, context);
                        return;
                    }
                    // If we didn't find any class declarations, we might be in a function that wraps a mixin
                    // Therefore find the return statement and call this method recursively
                    var returnNode = findChild(declaration, ts.isReturnStatement);
                    if (returnNode != null && returnNode.expression != null && returnNode.expression !== node) {
                        resolveAndExtendHeritage(returnNode.expression, flavors, context);
                        return;
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (declarations_1_1 && !declarations_1_1.done && (_b = declarations_1.return)) _b.call(declarations_1);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
    }
    else {
        var declarations = resolveDeclarations(node, context);
        try {
            // Visit component declarations for each inherited node.
            for (var declarations_2 = __values(declarations), declarations_2_1 = declarations_2.next(); !declarations_2_1.done; declarations_2_1 = declarations_2.next()) {
                var declaration = declarations_2_1.value;
                extendWithDeclarationNode(declaration, flavors, context);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (declarations_2_1 && !declarations_2_1.done && (_c = declarations_2.return)) _c.call(declarations_2);
            }
            finally { if (e_7) throw e_7.error; }
        }
    }
}
function extendWithDeclarationNode(declaration, flavors, context) {
    var ts = context.ts;
    if (ts.isInterfaceDeclaration(declaration) || ts.isClassLike(declaration)) {
        context.emitInheritNode(declaration);
    }
    if (context.config.analyzeLibDom || !isNodeInLibDom(declaration)) {
        visitComponentDeclaration(declaration, flavors, context);
    }
}

/**
 * Visits the source file and finds all component definitions as "customElements.define".
 * Next it dedupes definitions and parses the corresponding component declaration for each definition.
 * @param sourceFile
 * @param flavors
 * @param context
 */
function parseComponentDefinitions(sourceFile, flavors, context) {
    var e_1, _a, e_2, _b;
    // Find all definitions in the file
    var definitionResults = parseComponentDefinitionResults(sourceFile, flavors, context);
    // Emit diagnostics for invalid custom element tag names.
    if (context.config.diagnostics && !isNodeInLibDom(sourceFile)) {
        try {
            for (var definitionResults_1 = __values(definitionResults), definitionResults_1_1 = definitionResults_1.next(); !definitionResults_1_1.done; definitionResults_1_1 = definitionResults_1.next()) {
                var result = definitionResults_1_1.value;
                if (!isValidCustomElementName(result.tagName)) {
                    context.emitDiagnostics({
                        node: result.identifierNode,
                        message: "The tag name '" + result.tagName + "' is not a valid custom element name. Remember that a hyphen (-) is required.",
                        severity: "warning"
                    });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (definitionResults_1_1 && !definitionResults_1_1.done && (_a = definitionResults_1.return)) _a.call(definitionResults_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    // Go through each component declaration parsing and merging declarations.
    // We can have many definition results for the same tag name but with different declaration nodes.
    var declarationMap = new Map();
    try {
        for (var definitionResults_2 = __values(definitionResults), definitionResults_2_1 = definitionResults_2.next(); !definitionResults_2_1.done; definitionResults_2_1 = definitionResults_2.next()) {
            var definitionResult = definitionResults_2_1.value;
            // Pick flavors to test. If a "declarationHandler" has been chosen set, only pick this one, else pick all flavors.
            var relevantFlavors = (definitionResult.declarationHandler && [{ parseDeclarationMembers: definitionResult.declarationHandler }]) || flavors;
            // Parse the component declaration (inside this function is all the juicy stuff)
            var declaration = parseComponentDeclaration(definitionResult.declarationNode, relevantFlavors, context);
            // Merge the declarations if necessary
            var tagName = definitionResult.tagName;
            var existingDeclaration = declarationMap.get(tagName);
            if (existingDeclaration != null) {
                declarationMap.set(tagName, mergeDeclarations([declaration, existingDeclaration], context));
            }
            else {
                declarationMap.set(tagName, declaration);
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (definitionResults_2_1 && !definitionResults_2_1.done && (_b = definitionResults_2.return)) _b.call(definitionResults_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    // Only emit one definition per tag name.
    return __spread(declarationMap.entries()).map(function (_a) {
        var _b = __read(_a, 2), tagName = _b[0], declaration = _b[1];
        // Find the first definition result with this tag name in the list.
        var definitionNode = definitionResults.find(function (res) { return res.tagName === tagName; }).definitionNode;
        return {
            fromLib: isNodeInLibDom(definitionNode),
            node: definitionNode,
            tagName: tagName,
            declaration: expandDeclarationFromJsDoc(declaration)
        };
    });
}
/**
 * Finds all component definitions in a file.
 * @param node
 * @param flavors
 * @param context
 */
function parseComponentDefinitionResults(node, flavors, context) {
    var e_3, _a;
    if (node == null)
        return [];
    var resultMap = [];
    var definitionContext = __assign(__assign({}, context), { emitDefinitionResult: function (result) {
            // Definitions are unique by the declaration node and tag name combination.
            // This is because multiple definitions can exist side by side for the same tag name (think global TagName type definition and customElements.define)
            var existingResult = resultMap.find(function (r) { return r.declarationNode === result.declarationNode && r.tagName === result.tagName; });
            if (existingResult != null) {
                // Never overwrite a definition if it has a declaration handler.
                if (existingResult.declarationHandler != null)
                    return;
                // Merge the two definitions.
                Object.assign(existingResult, result);
            }
            else {
                resultMap.push(result);
            }
        } });
    try {
        // Run through all flavors finding component definitions.
        for (var flavors_1 = __values(flavors), flavors_1_1 = flavors_1.next(); !flavors_1_1.done; flavors_1_1 = flavors_1.next()) {
            var flavor = flavors_1_1.value;
            if (flavor.visitComponentDefinitions == null)
                continue;
            flavor.visitComponentDefinitions(node, definitionContext);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (flavors_1_1 && !flavors_1_1.done && (_a = flavors_1.return)) _a.call(flavors_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return __spread(resultMap);
}

/**
 * Visits the source file and finds all global event declarations in the file.
 * @param node
 * @param flavors
 * @param context
 */
function parseGlobalEvents(node, flavors, context) {
    var e_1, _a;
    if (node == null)
        return [];
    var globalEvents = [];
    try {
        for (var flavors_1 = __values(flavors), flavors_1_1 = flavors_1.next(); !flavors_1_1.done; flavors_1_1 = flavors_1.next()) {
            var flavor = flavors_1_1.value;
            if (flavor.visitGlobalEvents == null)
                continue;
            flavor.visitGlobalEvents(node, __assign(__assign({}, context), { emitEvent: function (event) {
                    globalEvents.push(event);
                } }));
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (flavors_1_1 && !flavors_1_1.done && (_a = flavors_1.return)) _a.call(flavors_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return globalEvents;
}

var DEFAULT_FLAVORS = [new LitElementFlavor(), new CustomElementFlavor(), new JsDocFlavor(), new StencilFlavor()];
/**
 * Analyzes all components in a source file.
 * @param sourceFile
 * @param options
 */
function analyzeComponents(sourceFile, options) {
    var diagnostics = [];
    // Assign defaults
    var flavors = options.flavors || DEFAULT_FLAVORS;
    var ts = options.ts || tsModule;
    var checker = options.checker;
    // Create context
    var context = {
        checker: checker,
        ts: ts,
        config: options.config || {},
        emitDiagnostics: function (diagnostic) {
            diagnostics.push(diagnostic);
        }
    };
    // Parse all components
    var componentDefinitions = parseComponentDefinitions(sourceFile, flavors, context);
    // Parse all global events
    var globalEvents = parseGlobalEvents(sourceFile, flavors, context);
    return {
        sourceFile: sourceFile,
        globalEvents: globalEvents,
        componentDefinitions: componentDefinitions,
        diagnostics: diagnostics
    };
}

/**
 * This function analyzes only the HTMLElement declaration found in "lib.dom.d.ts" source file provided by Typescript.
 * @param program
 * @param ts
 */
function analyzeLibDomHtmlElement(program, ts) {
    if (ts === void 0) { ts = tsModule; }
    var checker = program.getTypeChecker();
    var endsWithLibDom = "lib.dom.d.ts";
    var domLibSourceFile = program.getSourceFiles().find(function (sf) { return sf.fileName.endsWith(endsWithLibDom); });
    if (domLibSourceFile == null) {
        return undefined;
        //throw new Error(`Couldn't find '${endsWith}'. Have you included the 'dom' lib in your tsconfig?`);
    }
    return visit(domLibSourceFile, {
        checker: checker,
        ts: ts,
        config: {
            analyzeLibDom: true
        },
        emitDiagnostics: function (diagnostic) { }
    });
}
function visit(node, context) {
    if (context.ts.isInterfaceDeclaration(node) && node.name.text === "HTMLElement") {
        return parseComponentDeclaration(node, [new CustomElementFlavor()], context);
    }
    return node.forEachChild(function (child) {
        return visit(child, context);
    });
}

var VERSION = "0.1.18";

/**
 * The most general version of compiler options.
 */
var defaultOptions = {
    noEmitOnError: false,
    allowJs: true,
    experimentalDecorators: true,
    target: tsModule.ScriptTarget.Latest,
    downlevelIteration: true,
    module: tsModule.ModuleKind.ESNext,
    //module: ModuleKind.CommonJS,
    //lib: ["esnext", "dom"],
    strictNullChecks: true,
    moduleResolution: tsModule.ModuleResolutionKind.NodeJs,
    esModuleInterop: true,
    noEmit: true,
    allowSyntheticDefaultImports: true,
    allowUnreachableCode: true,
    allowUnusedLabels: true,
    skipLibCheck: true,
    isolatedModules: true
};
/**
 * Compiles an array of file paths using typescript.
 * @param filePaths
 * @param options
 */
function compileTypescript(filePaths, options) {
    if (options === void 0) { options = defaultOptions; }
    filePaths = Array.isArray(filePaths) ? filePaths : [filePaths];
    var program = tsModule.createProgram(filePaths, options);
    var diagnostics = tsModule.getPreEmitDiagnostics(program);
    var files = program.getSourceFiles().filter(function (sf) { return filePaths.includes(sf.fileName); });
    return { diagnostics: diagnostics, program: program, files: files };
}

/**
 * Flattens an array.
 * @param array
 */
function flatten(array) {
    return array.reduce(function (acc, a) { return __spread(acc, a); }, []);
}
/**
 * Pretty print the results for debugging.
 * @param results
 * @param checker
 */
function prepareResultForPrettyPrint(results, checker) {
    return results.map(function (result) {
        var tags = result.componentDefinitions.map(function (_a) {
            var declaration = _a.declaration, tagName = _a.tagName;
            return ({
                fileName: declaration.node.getSourceFile().fileName,
                tagName: tagName,
                description: declaration.jsDoc && declaration.jsDoc.comment,
                deprecated: declaration.deprecated,
                members: declaration.members.map(function (res) { return (__assign(__assign({}, res), { type: tsSimpleType.toTypeString(res.type, checker), node: null })); }),
                slots: declaration.slots.map(function (slot) { return ({
                    name: slot.name,
                    description: slot.jsDoc && slot.jsDoc.comment
                }); }),
                events: declaration.events.map(function (event) { return ({
                    name: event.name,
                    description: event.jsDoc && event.jsDoc.comment
                }); }),
                cssProperties: declaration.cssProperties.map(function (cssProperty) { return ({
                    name: cssProperty.name,
                    description: cssProperty.jsDoc && cssProperty.jsDoc.comment
                }); })
            });
        });
        var events = result.globalEvents.map(function (event) { return event.name; });
        return {
            fileName: result.sourceFile.fileName,
            tags: tags,
            events: events
        };
    });
}

var IGNORE_GLOBS = ["!**/node_modules/**", "!**/web_modules/**"];
//const DEFAULT_DIR_GLOB = "{,!(node_modules|web_modules)/}**/*.{js,jsx,ts,tsx}";
var DEFAULT_DIR_GLOB = "**/*.{js,jsx,ts,tsx}";
//const DEFAULT_FILE_GLOB = "**/*.{js,jsx,ts,tsx}";
var DEFAULT_GLOBS = [DEFAULT_DIR_GLOB]; //, DEFAULT_FILE_GLOB];
/**
 * Parses and analyses all globs and calls some callbacks while doing it.
 * @param globs
 * @param config
 * @param context
 */
function analyzeGlobs(globs, config, context) {
    if (context === void 0) { context = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var filePaths, _a, program, files, diagnostics, results, files_1, files_1_1, file, result, e_1_1;
        var e_1, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    // Set default glob
                    if (globs.length === 0) {
                        globs = DEFAULT_GLOBS;
                    }
                    return [4 /*yield*/, expandGlobs(globs, config)];
                case 1:
                    filePaths = _c.sent();
                    if (config.debug) {
                        console.log(filePaths);
                    }
                    // Callbacks
                    if (context.didExpandGlobs != null)
                        context.didExpandGlobs(filePaths);
                    if (context.willAnalyzeFiles != null)
                        context.willAnalyzeFiles(filePaths);
                    _a = compileTypescript(filePaths), program = _a.program, files = _a.files, diagnostics = _a.diagnostics;
                    if (diagnostics.length > 0) {
                        if (config.debug) {
                            console.dir(diagnostics.map(function (d) { return ((d.file && d.file.fileName) || "unknown") + ": " + tsModule.flattenDiagnosticMessageText(d.messageText, "\n"); }));
                        }
                        if (context.didFindTypescriptDiagnostics != null)
                            context.didFindTypescriptDiagnostics(diagnostics, { program: program });
                    }
                    results = [];
                    _c.label = 2;
                case 2:
                    _c.trys.push([2, 8, 9, 10]);
                    files_1 = __values(files), files_1_1 = files_1.next();
                    _c.label = 3;
                case 3:
                    if (!!files_1_1.done) return [3 /*break*/, 7];
                    file = files_1_1.value;
                    result = analyzeComponentsInFile(file, program, config);
                    if (config.debug) {
                        console.dir(prepareResultForPrettyPrint([result], program.getTypeChecker()), { depth: 10 });
                    }
                    if (!(context.emitAnalyzedFile != null)) return [3 /*break*/, 5];
                    return [4 /*yield*/, context.emitAnalyzedFile(file, result, { program: program })];
                case 4:
                    _c.sent();
                    _c.label = 5;
                case 5:
                    results.push(result);
                    _c.label = 6;
                case 6:
                    files_1_1 = files_1.next();
                    return [3 /*break*/, 3];
                case 7: return [3 /*break*/, 10];
                case 8:
                    e_1_1 = _c.sent();
                    e_1 = { error: e_1_1 };
                    return [3 /*break*/, 10];
                case 9:
                    try {
                        if (files_1_1 && !files_1_1.done && (_b = files_1.return)) _b.call(files_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                    return [7 /*endfinally*/];
                case 10: return [2 /*return*/, { program: program, diagnostics: diagnostics, files: files, results: results }];
            }
        });
    });
}
/**
 * Analyze all components in the typescript sourcefile using web component analyzer.
 * @param file
 * @param program
 * @param config
 */
function analyzeComponentsInFile(file, program, config) {
    var options = {
        checker: program.getTypeChecker(),
        config: config.analyze
    };
    return analyzeComponents(file, options);
}
/**
 * Expands the globs.
 * @param globs
 * @param config
 */
function expandGlobs(globs, config) {
    return __awaiter(this, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    globs = Array.isArray(globs) ? globs : [globs];
                    _a = flatten;
                    return [4 /*yield*/, Promise.all(globs.map(function (g) {
                            try {
                                // Test if the glob points to a directory.
                                // If so, return the result of a new glob that searches for files in the directory excluding node_modules..
                                var dirExists = fs.existsSync(g) && fs.lstatSync(g).isDirectory();
                                if (dirExists) {
                                    return fastGlob(__spread((config.analyzeLibraries || g.includes("node_modules") ? [] : IGNORE_GLOBS), [path.join(g, DEFAULT_DIR_GLOB)]), {
                                        absolute: true,
                                        followSymbolicLinks: false
                                    });
                                }
                            }
                            catch (e) { }
                            // Return the result of globbing
                            return fastGlob(__spread((config.analyzeLibraries || g.includes("node_modules") ? [] : IGNORE_GLOBS), [g]), {
                                absolute: true,
                                followSymbolicLinks: false
                            });
                        }))];
                case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
            }
        });
    });
}

/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
function debugJsonTransformer(results, program, config) {
    var definitions = flatten(results.map(function (res) { return res.componentDefinitions; }));
    return JSON.stringify(stripTypescriptValues(definitions), null, 2);
}
function isTypescriptNode(value) {
    return value instanceof Object && "kind" in value && "flags" in value;
}
function isTypescriptSourceFile(value) {
    return value instanceof Object && "kind" in value && "fileName" in value;
}
function isTypescriptType(value) {
    return value instanceof Object && "flags" in value && "checker" in value;
}
function stripTypescriptValues(input) {
    var e_1, _a;
    if (isTypescriptNode(input)) {
        return "{NODE}";
    }
    else if (isTypescriptSourceFile(input)) {
        return "{SOURCEFILE}";
    }
    else if (isTypescriptType(input)) {
        return "{TYPE}";
    }
    else if (Array.isArray(input)) {
        return input.map(stripTypescriptValues);
    }
    else if (input instanceof Object) {
        var obj = __assign({}, input);
        try {
            for (var _b = __values(Object.entries(input)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                obj[key] = stripTypescriptValues(value);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return obj;
    }
    return input;
}

/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
function jsonTransformer(results, program, config) {
    var checker = program.getTypeChecker();
    // Get all definitions
    var definitions = flatten(results.map(function (res) { return res.componentDefinitions; }));
    // Transform all definitions into "tags"
    var tags = definitions.map(function (d) { return definitionToHtmlDataTag(d, checker); });
    var htmlData = {
        version: 2,
        tags: tags
    };
    return JSON.stringify(htmlData, null, 2);
}
function definitionToHtmlDataTag(definition, checker) {
    var attributes = definition.declaration.members
        .map(function (d) { return componentMemberToHtmlDataAttribute(d, checker); })
        .filter(function (val) { return val != null; });
    var properties = definition.declaration.members
        .map(function (d) { return componentMemberToHtmlDataProperty(d, checker); })
        .filter(function (val) { return val != null; });
    var events = definition.declaration.events
        .map(function (e) { return componentEventToHtmlDataEvent(e); })
        .filter(function (val) { return val != null; });
    var slots = definition.declaration.slots
        .map(function (e) { return componentSlotToHtmlDataSlot(e); })
        .filter(function (val) { return val != null; });
    var cssProperties = definition.declaration.cssProperties
        .map(function (p) { return componentCssPropToHtmlCssProp(p); })
        .filter(function (val) { return val != null; });
    return {
        name: definition.tagName,
        description: getDescriptionFromJsDoc(definition.declaration.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(definition.declaration.jsDoc),
        attributes: attributes,
        properties: properties,
        events: events,
        slots: slots,
        cssProperties: cssProperties
    };
}
function componentCssPropToHtmlCssProp(prop, checker) {
    return {
        name: prop.name || "",
        description: getDescriptionFromJsDoc(prop.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(prop.jsDoc)
    };
}
function componentSlotToHtmlDataSlot(slot, checker) {
    return {
        name: slot.name || "",
        description: getDescriptionFromJsDoc(slot.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(slot.jsDoc)
    };
}
function componentEventToHtmlDataEvent(event, checker) {
    return {
        name: event.name,
        description: getDescriptionFromJsDoc(event.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(event.jsDoc)
    };
}
function componentMemberToHtmlDataAttribute(member, checker) {
    switch (member.kind) {
        case "attribute":
        case "property":
            if (member.attrName == null) {
                return undefined;
            }
            return {
                name: member.attrName,
                description: getDescriptionFromJsDoc(member.jsDoc),
                jsDoc: getJsDocTextFromJsDoc(member.jsDoc),
                type: getJsDocTypeFromType(member.type, checker)
            };
    }
    return undefined;
}
function componentMemberToHtmlDataProperty(member, checker) {
    switch (member.kind) {
        case "property":
            return {
                name: member.propName,
                description: getDescriptionFromJsDoc(member.jsDoc),
                jsDoc: getJsDocTextFromJsDoc(member.jsDoc),
                type: getJsDocTypeFromType(member.type, checker)
            };
    }
    return undefined;
}
function getDescriptionFromJsDoc(jsDoc) {
    return jsDoc != null ? jsDoc.comment : undefined;
}
function getJsDocTextFromJsDoc(jsDoc) {
    return jsDoc != null && jsDoc.node != null ? jsDoc.node.getText() : undefined;
}
function getJsDocTypeFromType(type, checker) {
    if (type == null)
        return undefined;
    // This function needs to return a jsdoc compatible type representation
    //   but "checker.typeToString" doesn't do that.
    return isTypescriptType$1(type) ? checker.typeToString(type) : tsSimpleType.toTypeString(type);
}
function isTypescriptType$1(value) {
    return value instanceof Object && "flags" in value && "checker" in value;
}

/**
 * Returns a markdown header with a specific level taking global start title level into account.
 * @param title
 * @param level
 * @param config
 */
function markdownHeader(title, level, config) {
    level = level - 1 + ((config.markdown && config.markdown.titleLevel) || 1);
    return "#".repeat(level) + " " + title;
}
/**
 * Returns a markdown table representation of the rows.
 * Strips unused columns.
 * @param rows
 * @param removeEmptyColumns
 */
function markdownTable(rows, _a) {
    var removeEmptyColumns = (_a === void 0 ? { removeEmptyColumns: true } : _a).removeEmptyColumns;
    // Constants for pretty printing the markdown tables
    var MIN_CELL_WIDTH = 3;
    var MAX_CELL_WIDTH = 50;
    var CELL_PADDING = 1;
    // Count the number of columns
    var columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));
    if (removeEmptyColumns) {
        // Create a boolean array where each entry tells if a column is used or not (excluding the header)
        var emptyColumns_1 = Array(columnCount)
            .fill(false)
            .map(function (b, i) { return i !== 0 && rows.slice(1).find(function (r) { return r[i] != null && r[i].length > 0; }) == null; });
        // Remove unused columns if necessary
        if (emptyColumns_1.includes(true)) {
            // Filter out the unused columns in each row
            rows = rows.map(function (row) { return row.filter(function (column, i) { return !emptyColumns_1[i]; }); });
            // Adjust the column count
            columnCount = Math.max.apply(Math, __spread(rows.map(function (r) { return r.length; })));
        }
    }
    // Escape all cells in the markdown output
    rows = rows.map(function (r) { return r.map(markdownEscapeTableCell); });
    // Create a boolean array where each entry corresponds to the preferred column width.
    // This is done by taking the largest width of all cells in each column.
    var columnWidths = Array(columnCount)
        .fill(0)
        .map(function (c, i) { return Math.min(MAX_CELL_WIDTH, Math.max.apply(Math, __spread([MIN_CELL_WIDTH], rows.map(function (r) { return (r[i] || "").length; }))) + CELL_PADDING * 2); });
    // Build up the table
    return "\n|" + rows[0].map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join("|") + "|\n|" + columnWidths.map(function (c) { return "-".repeat(c); }).join("|") + "|\n" + rows
        .slice(1)
        .map(function (r) { return "|" + r.map(function (r, i) { return fillWidth(r, columnWidths[i], CELL_PADDING); }).join("|") + "|"; })
        .join("\n") + "\n";
}
/**
 * Escape a text so it can be used in a markdown table
 * @param text
 */
function markdownEscapeTableCell(text) {
    return text.replace(/\n/g, "<br />").replace(/\|/g, "\\|");
}
/**
 * Highlights some text
 * @param text
 */
function markdownHighlight(text) {
    return "`" + text + "`";
}
/**
 * Creates padding around some text with a target width.
 * @param text
 * @param width
 * @param paddingStart
 */
function fillWidth(text, width, paddingStart) {
    return " ".repeat(paddingStart) + text + " ".repeat(Math.max(1, width - text.length - paddingStart));
}

/**
 * Transforms the component results to markdown
 * @param results
 * @param program
 * @param config
 */
function markdownTransformer(results, program, config) {
    // Grab all definitions
    var definitions = flatten(results.map(function (res) { return res.componentDefinitions; }));
    // Transform all definitions to markdown
    var markdownSegments = definitions.map(function (definition) {
        var declaration = definition.declaration;
        // Add tagName as header
        var segmentText = markdownHeader(definition.tagName, 1, config);
        // Add component jsdoc comment to the output
        if (declaration.jsDoc != null && declaration.jsDoc.comment != null)
            segmentText += "\n\n" + declaration.jsDoc.comment + "\n";
        // Grab all items from the component and add them as tables to the output.
        var properties = declaration.members
            .filter(function (m) { return m.kind === "property"; })
            .sort(function (a, b) { return (a.propName < b.propName ? -1 : 1); });
        var attributes = declaration.members
            .filter(function (m) { return m.kind === "attribute"; })
            .sort(function (a, b) { return (a.attrName < b.attrName ? -1 : 1); });
        var slots = declaration.slots.sort(function (a, b) { return (a.name == null ? -1 : b.name == null ? 1 : a.name < b.name ? -1 : 1); });
        var events = declaration.events.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        var cssProps = declaration.cssProperties.sort(function (a, b) { return (a.name < b.name ? -1 : 1); });
        if (attributes.length > 0) {
            segmentText += "\n" + memberAttributeSection(attributes, program.getTypeChecker(), config);
        }
        if (properties.length > 0) {
            segmentText += "\n" + memberPropertySection(properties, program.getTypeChecker(), config);
        }
        if (events.length > 0) {
            segmentText += "\n" + eventSection(events, config, program.getTypeChecker());
        }
        if (cssProps.length > 0) {
            segmentText += "\n" + cssPropSection(cssProps, config);
        }
        if (slots.length > 0) {
            segmentText += "\n" + slotSection(slots, config);
        }
        return segmentText;
    });
    return markdownSegments.join("\n\n");
}
/**
 * Returns a markdown table with css props
 * @param cssProperty
 * @param config
 */
function cssPropSection(cssProperty, config) {
    var rows = [["Property", "Description"]];
    rows.push.apply(rows, __spread(cssProperty.map(function (prop) { return [(prop.name && markdownHighlight(prop.name)) || "", (prop.jsDoc && prop.jsDoc.comment) || ""]; })));
    return markdownHeader("CSS Custom Properties", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with events
 * @param events
 * @param config
 * @param checker
 */
function eventSection(events, config, checker) {
    var rows = [["Event", "Detail", "Description"]];
    rows.push.apply(rows, __spread(events.map(function (event) { return [
        (event.name && markdownHighlight(event.name)) || "",
        tsSimpleType.isAssignableToSimpleTypeKind(event.type, tsSimpleType.SimpleTypeKind.ANY, checker) ? "" : markdownHighlight(tsSimpleType.toTypeString(event.type, checker)),
        (event.jsDoc && event.jsDoc.comment) || ""
    ]; })));
    return markdownHeader("Events", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with slots
 * @param slots
 * @param config
 */
function slotSection(slots, config) {
    var rows = [["Name", "Permitted Tag Names", "Description"]];
    rows.push.apply(rows, __spread(slots.map(function (slot) { return [
        (slot.name && markdownHighlight(slot.name)) || "",
        (slot.permittedTagNames && slot.permittedTagNames.map(function (tagName) { return markdownHighlight(tagName); }).join(" | ")) || "",
        (slot.jsDoc && slot.jsDoc.comment) || ""
    ]; })));
    return markdownHeader("Slots", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with attributes.
 * @param members
 * @param checker
 * @param config
 */
function memberAttributeSection(members, checker, config) {
    var e_1, _a;
    var rows = [["Attribute", "Type", "Default", "Description"]];
    try {
        // Add members as rows one by one
        for (var members_1 = __values(members), members_1_1 = members_1.next(); !members_1_1.done; members_1_1 = members_1.next()) {
            var member = members_1_1.value;
            var attrName = markdownHighlight(member.attrName);
            var type = markdownHighlight(tsSimpleType.toTypeString(member.type, checker));
            var def = (member.default !== undefined ? JSON.stringify(member.default) : "") || (member.required && "**required**") || "";
            var comment = (member.jsDoc && member.jsDoc.comment) || "";
            rows.push([attrName, type, def, comment]);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (members_1_1 && !members_1_1.done && (_a = members_1.return)) _a.call(members_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return markdownHeader("Attributes", 2, config) + "\n" + markdownTable(rows);
}
/**
 * Returns a markdown table with properties
 * @param members
 * @param checker
 * @param config
 */
function memberPropertySection(members, checker, config) {
    var e_2, _a;
    var rows = [["Property", "Attribute", "Type", "Default", "Description"]];
    try {
        // Add properties as rows one by one
        for (var members_2 = __values(members), members_2_1 = members_2.next(); !members_2_1.done; members_2_1 = members_2.next()) {
            var member = members_2_1.value;
            var propName = markdownHighlight(member.propName);
            var attrName = (member.attrName && markdownHighlight(member.attrName)) || "";
            var type = markdownHighlight(tsSimpleType.toTypeString(member.type, checker));
            var def = (member.default !== undefined ? JSON.stringify(member.default) : "") || (member.required && "**required**") || "";
            var comment = (member.jsDoc && member.jsDoc.comment) || "";
            rows.push([propName, attrName, type, def, comment]);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (members_2_1 && !members_2_1.done && (_a = members_2.return)) _a.call(members_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return markdownHeader("Properties", 2, config) + "\n" + markdownTable(rows);
}

/**
 * Vscode json output format transformer.
 * @param results
 * @param program
 * @param config
 */
function vscodeTransformer(results, program, config) {
    var checker = program.getTypeChecker();
    // Grab all definitions
    var definitions = results.map(function (res) { return res.componentDefinitions; }).reduce(function (acc, cur) { return __spread(acc, cur); }, []);
    // Transform all definitions into "tags"
    var tags = definitions.map(function (d) { return definitionToHtmlDataTag$1(d, checker); });
    var vscodeJson = {
        version: 1,
        tags: tags,
        globalAttributes: [],
        valueSets: []
    };
    return JSON.stringify(vscodeJson, null, 2);
}
function definitionToHtmlDataTag$1(definition, checker) {
    // Transform all members into "attributes"
    var customElementAttributes = definition.declaration.members
        .map(function (d) { return componentMemberToVscodeAttr(d, checker); })
        .filter(function (val) { return val != null; });
    var eventAttributes = definition.declaration.events
        .map(function (e) { return componentEventToVscodeAttr(e, checker); })
        .filter(function (val) { return val != null; });
    var attributes = __spread(customElementAttributes, eventAttributes);
    return {
        name: definition.tagName,
        description: formatMetadata(definition.declaration.jsDoc, {
            Events: definition.declaration.events.map(function (e) { return formatEntryRow(e.name, e.jsDoc, e.type, checker); }),
            Slots: definition.declaration.slots.map(function (s) {
                return formatEntryRow(s.name || " ", s.jsDoc, s.permittedTagNames && s.permittedTagNames.map(function (n) { return "\"" + markdownHighlight(n) + "\""; }).join(" | "), checker);
            }),
            Attributes: definition.declaration.members
                .map(function (m) { return ("attrName" in m && m.attrName != null ? formatEntryRow(m.attrName, m.jsDoc, m.type, checker) : undefined); })
                .filter(function (m) { return m != null; }),
            Properties: definition.declaration.members
                .map(function (m) { return ("propName" in m && m.propName != null ? formatEntryRow(m.propName, m.jsDoc, m.type, checker) : undefined); })
                .filter(function (m) { return m != null; })
        }),
        attributes: attributes
    };
}
function componentEventToVscodeAttr(event, checker) {
    return {
        name: "on" + event.name,
        description: formatEntryRow(event.name, event.jsDoc, event.type, checker)
    };
}
function componentMemberToVscodeAttr(member, checker) {
    switch (member.kind) {
        case "attribute":
        case "property":
            if (member.attrName == null) {
                return undefined;
            }
            return __assign({ name: member.attrName, description: formatMetadata(formatEntryRow(member.attrName, member.jsDoc, member.type, checker), {
                    Property: "propName" in member ? member.propName : undefined,
                    Default: member.default === undefined ? undefined : String(member.default)
                }) }, (typeToVscodeValuePart(member.type, checker) || {}));
        case "method":
            return undefined;
    }
}
/**
 * Converts a type to either a value set or string unions.
 * @param type
 * @param checker
 */
function typeToVscodeValuePart(type, checker) {
    var simpleType = tsSimpleType.isSimpleType(type) ? type : tsSimpleType.toSimpleType(type, checker);
    switch (simpleType.kind) {
        case tsSimpleType.SimpleTypeKind.BOOLEAN:
            return { valueSet: "v" };
        case tsSimpleType.SimpleTypeKind.STRING_LITERAL:
            return { values: [{ name: simpleType.value }] };
        case tsSimpleType.SimpleTypeKind.ENUM:
            return { values: typesToStringUnion(simpleType.types.map(function (_a) {
                    var type = _a.type;
                    return type;
                })) };
        case tsSimpleType.SimpleTypeKind.UNION:
            return { values: typesToStringUnion(simpleType.types) };
    }
    return undefined;
}
/**
 * Returns a list of strings that represents the types.
 * Only looks at literal types and strips the rest.
 * @param types
 */
function typesToStringUnion(types) {
    return types
        .map(function (t) {
        switch (t.kind) {
            case tsSimpleType.SimpleTypeKind.STRING_LITERAL:
            case tsSimpleType.SimpleTypeKind.NUMBER_LITERAL:
                return { name: t.value.toString() };
            default:
                return undefined;
        }
    })
        .filter(function (val) { return val != null; });
}
/**
 * Formats description and metadata so that it can be used in documentation.
 * @param doc
 * @param metadata
 */
function formatMetadata(doc, metadata) {
    var metaText = Object.entries(metadata)
        .map(function (_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        if (value == null) {
            return undefined;
        }
        else if (Array.isArray(value)) {
            var filtered = value.filter(function (v) { return v != null; });
            if (filtered.length === 0)
                return undefined;
            return key + ":\n\n" + filtered.map(function (v) { return "  * " + v; }).join("\n\n");
        }
        else if (typeof value === "string") {
            return key + ": " + value;
        }
    })
        .filter(function (value) { return value != null; })
        .join("\n\n");
    var comment = doc == null ? undefined : typeof doc === "string" ? doc : doc.comment && doc.comment;
    return "" + (comment || "") + (metadata ? "" + (comment ? "\n\n" : "") + metaText : "") || undefined;
}
/**
 * Formats name, doc and type so that it can be presented in documentation
 * @param name
 * @param doc
 * @param type
 * @param checker
 */
function formatEntryRow(name, doc, type, checker) {
    var comment = doc == null ? undefined : typeof doc === "string" ? doc : doc.comment && doc.comment;
    var typeText = type == null ? undefined : typeof type === "string" ? type : formatType(type, checker);
    return "" + markdownHighlight(name) + (typeText == null ? "" : " {" + typeText + "}") + (comment == null ? "" : " - ") + (comment || "");
}
/**
 * Formats a type to present in documentation
 * @param type
 * @param checker
 */
function formatType(type, checker) {
    return !tsSimpleType.isAssignableToSimpleTypeKind(type, tsSimpleType.SimpleTypeKind.ANY, checker) ? markdownHighlight(tsSimpleType.toTypeString(type, checker)) : undefined;
}

var CommandError = /** @class */ (function (_super) {
    __extends(CommandError, _super);
    function CommandError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CommandError;
}(Error));

/**
 * A CLI command for analyzing components.
 */
var AnalyzeCliCommand = /** @class */ (function () {
    function AnalyzeCliCommand() {
        this.id = "analyze";
    }
    /**
     * Prints help for this command.
     */
    AnalyzeCliCommand.prototype.printHelp = function () {
        console.log("Usage:\n  $ wca analyze [<input-glob>] [options]\n  \nExamples:\n  $ wca analyze\n  $ wca analyze src --format markdown\n  $ wca analyze \"src/**/*.{js,ts}\" --outDir output\n  $ wca analyze my-element.js --outFile output.json\n\nOptions:\n  --help\t\tPrint this message.\n  --format FORMAT\tSpecify output format. The possible options are:\n\t\t\t  o md | markdown\tMarkdown format (default)\n\t\t\t  o json\t\tJSON format\n\t\t\t  o vscode\t\tVscode JSON format\n  --outFile FILE\tConcatenate and emit output to a single file.\n  --outDir DIRECTORY\tDirect output to a directory where each file corresponds to a web component.\n");
    };
    /**
     * Runs the analyze cli command.
     * @param config
     * @param inputGlobs
     */
    AnalyzeCliCommand.prototype.run = function (config) {
        var inputGlobs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            inputGlobs[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var context, dirPath_1, extName_1, _a, results, program, transformed, path$1;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        context = {
                            didExpandGlobs: function (filePaths) {
                                if (filePaths.length === 0) {
                                    throw new CommandError("Didn't find any files to analyze.");
                                }
                            },
                            willAnalyzeFiles: function (filePaths) {
                                console.log("Analyzing " + filePaths.length + " file" + (filePaths.length === 1 ? "" : "s") + "...");
                            }
                        };
                        if (!(config.outDir != null)) return [3 /*break*/, 2];
                        // Create the directory if it doesn't exist.
                        if (!fs.existsSync(config.outDir)) {
                            fs.mkdirSync(config.outDir);
                        }
                        dirPath_1 = config.outDir;
                        extName_1 = (function () {
                            switch (config.format) {
                                case "json":
                                case "vscode":
                                    return ".json";
                                case "md":
                                case "markdown":
                                    return ".md";
                                default:
                                    return ".txt";
                            }
                        })();
                        // Analyze all globs
                        return [4 /*yield*/, analyzeGlobs(inputGlobs, config, __assign(__assign({}, context), { emitAnalyzedFile: function (file, result, _a) {
                                    var program = _a.program;
                                    // Write file to disc for each analyzed file
                                    var definition = result.componentDefinitions[0];
                                    if (definition == null)
                                        return;
                                    // The name of the file becomes the tagName of the first component definition in the file.
                                    var path$1 = path.resolve(process.cwd(), dirPath_1, definition.tagName) + extName_1;
                                    var transformed = _this.transformResults(result, program, config);
                                    fs.writeFileSync(path$1, transformed);
                                } }))];
                    case 1:
                        // Analyze all globs
                        _b.sent();
                        return [3 /*break*/, 6];
                    case 2:
                        if (!(config.outFile != null)) return [3 /*break*/, 4];
                        // Guess format based on outFile extension
                        config.format =
                            config.format ||
                                (function () {
                                    if (config.outFile == null)
                                        return undefined;
                                    var extName = path.extname(config.outFile);
                                    switch (extName) {
                                        case ".json":
                                            return "json";
                                        case ".md":
                                            return "markdown";
                                    }
                                })() ||
                                "markdown";
                        return [4 /*yield*/, analyzeGlobs(inputGlobs, config, context)];
                    case 3:
                        _a = _b.sent(), results = _a.results, program = _a.program;
                        transformed = this.transformResults(results, program, config);
                        path$1 = path.resolve(process.cwd(), config.outFile);
                        console.log("Writing result to \"" + config.outFile + "\"");
                        fs.writeFileSync(path$1, transformed);
                        return [3 /*break*/, 6];
                    case 4: return [4 /*yield*/, analyzeGlobs(inputGlobs, config, __assign(__assign({}, context), { emitAnalyzedFile: function (file, result, _a) {
                                var program = _a.program;
                                // Only emit the result if there is in fact components in the file.
                                if (result.componentDefinitions.length > 0 || result.globalEvents.length > 0) {
                                    var transformed = _this.transformResults(result, program, config);
                                    console.log(transformed);
                                }
                            } }))];
                    case 5:
                        _b.sent();
                        _b.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Analyzes input globs and returns the transformed result.
     * @param inputGlobs
     * @param config
     */
    AnalyzeCliCommand.prototype.analyze = function (inputGlobs, config) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, results, program;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, analyzeGlobs(Array.isArray(inputGlobs) ? inputGlobs : [inputGlobs], config)];
                    case 1:
                        _a = _b.sent(), results = _a.results, program = _a.program;
                        return [2 /*return*/, this.transformResults(results, program, config)];
                }
            });
        });
    };
    /**
     * Transforms analyze results based on the wca cli config.
     * @param results
     * @param program
     * @param config
     */
    AnalyzeCliCommand.prototype.transformResults = function (results, program, config) {
        results = Array.isArray(results) ? results : [results];
        // Default format is "md"
        var format = config.format || "md";
        switch (format) {
            case "md":
            case "markdown":
                return markdownTransformer(results, program, config);
            case "vscode":
                return vscodeTransformer(results, program);
            case "debug":
                return debugJsonTransformer(results);
            case "json":
                console.log("\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                console.log("  WARNING: This json format is for experimental and demo purposes. You can expect changes to this format.");
                console.log("  Please follow and contribute to the discussion at:");
                console.log("  - https://github.com/webcomponents/custom-elements-json");
                console.log("  - https://github.com/w3c/webcomponents/issues/776");
                console.log("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
                return jsonTransformer(results, program);
            default:
                throw new CommandError("Invalid output format '" + config.format + "'");
        }
    };
    return AnalyzeCliCommand;
}());

/**
 * Prints all diagnostics of the analyze components result.
 * @param result
 */
function printResultDiagnostics(result) {
    var e_1, _a;
    if (Array.isArray(result)) {
        return result.forEach(printResultDiagnostics);
    }
    var diagnostics = result.diagnostics;
    // Return right away if there are no diagnostics
    if (diagnostics.length === 0)
        return;
    // Pretty-print the filename
    var fileName = path.relative(process.cwd(), result.sourceFile.fileName);
    console.log(diagnostics.length + " diagnostics in \"" + fileName + "\"");
    try {
        // Print all diagnostics
        for (var diagnostics_1 = __values(diagnostics), diagnostics_1_1 = diagnostics_1.next(); !diagnostics_1_1.done; diagnostics_1_1 = diagnostics_1.next()) {
            var diagnostic = diagnostics_1_1.value;
            console.log("\uFE0F" + getSeverityBox(diagnostic.severity) + " " + getFileLocation(diagnostic.node) + ": " + diagnostic.message);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (diagnostics_1_1 && !diagnostics_1_1.done && (_a = diagnostics_1.return)) _a.call(diagnostics_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    console.log("");
}
/**
 * Returns the location of the node.
 * @param node
 */
function getFileLocation(node) {
    var line = node.getSourceFile().getLineAndCharacterOfPosition(node.getStart()).line;
    return "line " + (line + 1);
}
/**
 * Returns a "severity box": a colored box with a label.
 * @param severity
 */
function getSeverityBox(severity) {
    switch (severity) {
        case "error":
            return "\x1b[0;30;41m error \x1b[0m";
        case "warning":
            return "\x1b[0;30;43m warning \x1b[0m";
        default:
            return "";
    }
}

/**
 * A CLI command for emitting diagnostics for components.
 */
var DiagnoseCliCommand = /** @class */ (function () {
    function DiagnoseCliCommand() {
        this.id = "diagnose";
    }
    /**
     * Prints the help text for this command.
     */
    DiagnoseCliCommand.prototype.printHelp = function () {
        console.log("Usage:\n  $ wca diagnose [<input-glob>] [options]\n  \nExamples:\n  $ wca diagnose\n  $ wca diagnose src\n  $ wca diagnose \"./src/**/*.{js,ts}\"\n  $ wca diagnose my-element.js\n\nOptions:\n  --help\t\tPrint this message.\n");
    };
    /**
     * Runs this command
     * @param config
     * @param inputGlobs
     */
    DiagnoseCliCommand.prototype.run = function (config) {
        var inputGlobs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            inputGlobs[_i - 1] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            var passed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        passed = true;
                        // Set "diagnostics" to true in the analyze configuration.
                        config.analyze = __assign(__assign({}, (config.analyze || {})), { diagnostics: true });
                        // Analyze the globs and emit diagnostics.
                        return [4 /*yield*/, analyzeGlobs(inputGlobs, config, {
                                didExpandGlobs: function (filePaths) {
                                    if (filePaths.length === 0) {
                                        throw new CommandError("Didn't find any files to analyze.");
                                    }
                                },
                                willAnalyzeFiles: function (filePaths) {
                                    console.log("Analyzing " + filePaths.length + " file" + (filePaths.length === 1 ? "" : "s") + "...");
                                },
                                emitAnalyzedFile: function (file, result, _a) {
                                    var program = _a.program;
                                    // Print diagnostics of the result.
                                    printResultDiagnostics(result);
                                    if (result.diagnostics.length > 0) {
                                        passed = false;
                                    }
                                }
                            })];
                    case 1:
                        // Analyze the globs and emit diagnostics.
                        _a.sent();
                        return [2 /*return*/, passed ? 0 : 1];
                }
            });
        });
    };
    return DiagnoseCliCommand;
}());

/**
 * Parses CLI arguments.
 * @param args
 */
function parseCliArguments(args) {
    var result = { _: [] };
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        // Parses: "--key", "-k", "--key=value", "--key value"
        if (arg.startsWith("-")) {
            // Parses: "--key=value"
            if (arg.includes("=")) {
                var _a = __read(arg.split("="), 2), key = _a[0], value = _a[1];
                assignValue(result, key, value);
            }
            // Parses: "--key value", "--key", "-k
            else {
                var key = transformKey(arg);
                // Parses: "--key value"
                if (i < args.length - 1) {
                    var value = args[i + 1];
                    if (!value.startsWith("-")) {
                        assignValue(result, key, value);
                        i++;
                        continue;
                    }
                }
                // Parses: "--key", "-k"
                assignValue(result, key, true);
            }
        }
        // Parses: "arg1", "arg2", ...
        else {
            result._.push(arg);
        }
    }
    return result;
}
/**
 * Transform a string to a primitive type.
 * @param value
 */
function transformValue(value) {
    if (typeof value === "boolean") {
        return value;
    }
    else if (!isNaN(Number(value))) {
        return Number(value);
    }
    else if (value === "true" || value === "false") {
        return value === "true";
    }
    return value;
}
/**
 * Transform a key by removing the first "-" characters.
 * @param key
 */
function transformKey(key) {
    return key.replace(/^-*/g, "");
}
/**
 * Assigns a value on a specific key and transforms the value at the same time.
 * @param obj
 * @param key
 * @param value
 */
function assignValue(obj, key, value) {
    // The key could be "nested.key"
    var keys = transformKey(key).split(".");
    keys.forEach(function (k, i) {
        // Assign the final value
        if (i >= keys.length - 1) {
            obj[k] = transformValue(value);
        }
        // Create nested objects
        else {
            if (!(k in obj)) {
                obj[k] = {};
            }
            obj = obj[k];
        }
    });
}

/**
 * The main function of the cli.
 */
function cli() {
    return __awaiter(this, void 0, void 0, function () {
        var commands, args, commandId, command, exitCode, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    commands = [new AnalyzeCliCommand(), new DiagnoseCliCommand()];
                    args = parseCliArguments(process.argv.slice(2));
                    if ("debug" in args && args.debug) {
                        console.dir(args);
                    }
                    commandId = args._[0];
                    command = commands.find(function (c) { return c.id === commandId; });
                    // Print "version"
                    if ("version" in args) {
                        console.log(VERSION);
                        process.exit();
                    }
                    if (!(command == null)) return [3 /*break*/, 2];
                    if (commandId != null) {
                        console.log("Invalid command '" + commandId + "'\n");
                    }
                    return [4 /*yield*/, printGlobalHelp()];
                case 1:
                    _a.sent();
                    return [3 /*break*/, 7];
                case 2:
                    if (!("help" in args && command.printHelp != null)) return [3 /*break*/, 4];
                    return [4 /*yield*/, command.printHelp()];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 7];
                case 4:
                    _a.trys.push([4, 6, , 7]);
                    return [4 /*yield*/, command.run.apply(command, __spread([args], args._.slice(1)))];
                case 5:
                    exitCode = _a.sent();
                    process.exit(exitCode || 0);
                    return [3 /*break*/, 7];
                case 6:
                    error_1 = _a.sent();
                    if (error_1 instanceof CommandError) {
                        console.log("Error: ", error_1.message, "\n");
                        return [2 /*return*/, process.exit(1)];
                    }
                    else {
                        console.log("Fatal error: ", error_1.message);
                        throw error_1;
                    }

                case 7: return [2 /*return*/];
            }
        });
    });
}
/**
 * Prints the global help text.
 */
function printGlobalHelp() {
    console.log("Usage:\n  $ wca <command> [<input-glob>] [options]\n\nAvailable Commands:\n  analyze\tAnalyses components and emits results in a specified format.\n  diagnose\tAnalyses components and emits diagnostics to the console.\n  \nFor more info, run any command with the `--help` flag\n  $ wca analyze --help\n  $ wca diagnose --help\n  \nExamples:\n  $ wca analyze\n  $ wca analyze src --format markdown\n  $ wca analyze \"src/**/*.{js,ts}\" --outDir output\n  $ wca analyze my-element.js --outFile output.json\n  \n  $ wca diagnose\n  $ wca diagnose src\n  $ wca diagnose \"./src/**/*.{js,ts}\"\n  $ wca diagnose my-element.js\n");
}

exports.AnalyzeCliCommand = AnalyzeCliCommand;
exports.VERSION = VERSION;
exports.analyzeComponents = analyzeComponents;
exports.analyzeLibDomHtmlElement = analyzeLibDomHtmlElement;
exports.cli = cli;
exports.debugJsonTransformer = debugJsonTransformer;
exports.jsonTransformer = jsonTransformer;
exports.markdownTransformer = markdownTransformer;
exports.stripTypescriptValues = stripTypescriptValues;
exports.vscodeTransformer = vscodeTransformer;
