import { isAssignableToSimpleTypeKind, isSimpleType, SimpleTypeKind, toSimpleType } from "ts-simple-type";
import { mergeJsDocs } from "./merge-js-docs";
/**
 * Merges multiple component declarations.
 * @param declarations
 * @param context
 */
export function mergeDeclarations(declarations, context) {
    // Return right away if there is only 1 declaration.
    if (declarations.length === 1)
        return declarations[0];
    // Collect all items from all declarations.
    const members = declarations.map(dec => dec.members).reduce((acc, members) => [...acc, ...members], []);
    const events = declarations.map(dec => dec.events).reduce((acc, events) => [...acc, ...events], []);
    const slots = declarations.map(dec => dec.slots).reduce((acc, slots) => [...acc, ...slots], []);
    const cssProps = declarations.map(dec => dec.cssProperties).reduce((acc, cssProps) => [...acc, ...cssProps], []);
    // Merge all items
    const mergedJsDoc = mergeJsDocs(declarations[0].jsDoc, declarations.slice(1).map(dec => dec.jsDoc));
    const mergedMembers = mergeMembers(members, context);
    const mergedSlots = mergeSlots(slots);
    const mergedEvents = mergeEvents(events);
    const mergedCSSProps = mergeCSSProps(cssProps);
    return Object.assign(Object.assign({}, declarations[0]), { jsDoc: mergedJsDoc, members: mergedMembers, slots: mergedSlots, events: mergedEvents, cssProperties: mergedCSSProps });
}
/**
 * Merges slots
 * @param slots
 */
export function mergeSlots(slots) {
    return nameMerge(slots, "last");
}
/**
 * Merges events
 * @param events
 */
export function mergeEvents(events) {
    return nameMerge(events, "last");
}
/**
 * Merges css props
 * @param cssProps
 */
export function mergeCSSProps(cssProps) {
    return nameMerge(cssProps, "last");
}
/**
 * Merges based on a name and a direction.
 * "first": Only keep the first found item.
 * "last": Only keep the last found item.
 * This function always prefers one of the entries' jsDoc if defined
 * @param entries
 * @param direction
 */
function nameMerge(entries, direction) {
    if (direction === "last")
        entries = entries.reverse();
    const merged = new Map();
    for (const entry of entries) {
        const existing = merged.get(entry.name || "");
        if (existing == null) {
            merged.set(entry.name || "", entry);
        }
        else if (existing.jsDoc == null && entry.jsDoc != null) {
            merged.set(entry.name || "", Object.assign(Object.assign({}, existing), { jsDoc: entry.jsDoc }));
        }
    }
    return Array.from(merged.values());
}
/**
 * Merges all members in the list of members.
 * @param members
 * @param context
 */
export function mergeMembers(members, context) {
    const mergedMembers = [];
    // Loop through all members adding merged members to "mergedMembers"
    for (const member of members) {
        // Find a member that can be merged
        const existing = findMemberToMerge(mergedMembers, member);
        if (existing != null) {
            // Remove the item from the list and add the merged member
            mergedMembers.splice(mergedMembers.findIndex(m => m === existing), 1);
            const mergedMember = mergeMember(existing, member, context.checker);
            mergedMembers.push(mergedMember);
            // If we are merging into a property we may need to remove a corresponding attribute if present, because it's not represented from the property.
            if (mergedMember.kind === "property" && "attrName" in mergedMember) {
                const indexWithAttrName = mergedMembers.findIndex(m => m.kind === "attribute" && m.attrName === mergedMember.attrName);
                if (indexWithAttrName >= 0) {
                    mergedMembers.splice(indexWithAttrName, 1);
                }
            }
        }
        else {
            mergedMembers.push(member);
        }
    }
    return mergedMembers;
}
/**
 * Returns a member that can be merged with "similar".
 * @param members
 * @param similar
 */
function findMemberToMerge(members, similar) {
    if (similar.kind === "method")
        return undefined;
    // Merges attributes and properties based on the lowercased version of the name.
    const attrName = (similar.kind === "attribute" && similar.attrName.toLowerCase()) || undefined;
    const propName = (similar.kind === "property" && similar.propName.toLowerCase()) || undefined;
    // Return a member that matches either attrName or propName
    return members.find(member => {
        switch (member.kind) {
            case "attribute":
                return [attrName, propName].includes(member.attrName.toLowerCase());
            case "property":
                // If the member has an attrName compare it to the "attrName" of "similar"
                return ([attrName, propName].includes(member.propName.toLowerCase()) ||
                    (member.attrName != null ? member.attrName.toLowerCase() === attrName : false));
        }
        return false;
    });
}
/**
 * Merges two members
 * @param existing
 * @param newest
 * @param checker
 */
function mergeMember(existing, newest, checker) {
    switch (existing.kind) {
        case "property":
            switch (newest.kind) {
                case "property":
                    return mergeMemberIntoMember(existing, newest, checker);
                case "attribute":
                    return mergeAttrIntoProp(existing, newest, checker);
            }
            break;
        case "attribute":
            switch (newest.kind) {
                case "property":
                    return mergeAttrIntoProp(newest, existing, checker);
                case "attribute":
                    return mergeMemberIntoMember(existing, newest, checker);
            }
            break;
    }
    return existing;
}
/**
 * Merges an attribute into a property.
 * This operation prioritizes "attribute".
 * @param prop
 * @param attr
 * @param checker
 */
function mergeAttrIntoProp(prop, attr, checker) {
    return Object.assign(Object.assign({}, prop), { type: mergeTypes(prop.type, attr.type, checker), default: attr.default || prop.default, required: attr.required || prop.required, jsDoc: attr.jsDoc || prop.jsDoc, attrName: attr.attrName });
}
/**
 * Merges to members of the same kind into each other.
 * This operation basically merged their types and prioritizes "b".
 * @param a
 * @param b
 * @param checker
 */
function mergeMemberIntoMember(a, b, checker) {
    return Object.assign(Object.assign({}, b), { attrName: a.attrName || b.attrName, type: mergeTypes(a.type, b.type, checker) });
}
/**
 * Merges two types into each other.
 * This operation prioritizes "typeB" and returns "typeA" only if "typeB" is ANY and "typeA" is not ANY.
 * @param typeA
 * @param typeB
 * @param checker
 */
function mergeTypes(typeA, typeB, checker) {
    const simpleTypeB = isSimpleType(typeB) ? typeB : toSimpleType(typeB, checker);
    // If type B isn't assignable to "ANY", return it!
    if (!isAssignableToSimpleTypeKind(simpleTypeB, SimpleTypeKind.ANY)) {
        return typeB;
    }
    // Else if type A isn't assignable to "ANY" return it
    else if (!isAssignableToSimpleTypeKind(typeA, SimpleTypeKind.ANY, checker)) {
        return typeA;
    }
    // Else return "typeB"
    return typeB;
}
