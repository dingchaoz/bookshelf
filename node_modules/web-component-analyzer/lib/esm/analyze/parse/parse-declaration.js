import { findChild, isNodeInLibDom, resolveDeclarations } from "../util/ast-util";
import { getJsDoc } from "../util/js-doc-util";
import { expandMembersFromJsDoc } from "./expand-from-js-doc";
import { mergeCSSProps, mergeEvents, mergeMembers, mergeSlots } from "./merge-declarations";
import { mergeJsDocs } from "./merge-js-docs";
/**
 * Parses a component declaration using flavors.
 * @param declarationNode
 * @param flavors
 * @param context
 */
export function parseComponentDeclaration(declarationNode, flavors, context) {
    const slots = [];
    const members = [];
    const events = [];
    const cssProps = [];
    const inherits = new Set();
    const inheritNodes = new Set();
    // Visit the declaration node using flavors.
    visitComponentDeclaration(declarationNode, flavors, Object.assign(Object.assign({}, context), { declarationNode, features: {
            getCSSProps() {
                return cssProps;
            },
            getEvents() {
                return events;
            },
            getInheritNodes() {
                return Array.from(inheritNodes);
            },
            getInherits() {
                return Array.from(inherits);
            },
            getMembers() {
                return members;
            },
            getSlots() {
                return slots;
            }
        }, emitMembers(newMembers) {
            members.push(...newMembers);
        },
        emitInheritNode(node) {
            inheritNodes.add(node);
        },
        emitCSSProps(newCSSProps) {
            cssProps.push(...newCSSProps);
        },
        emitEvents(newEvents) {
            events.push(...newEvents);
        },
        emitSlots(newSlots) {
            slots.push(...newSlots);
        },
        emitInherit(name) {
            inherits.add(name);
        } }));
    // Merge all jsdoc tags using inherited nodes.
    const mainJsDoc = isDeclarationExcluded(declarationNode, context) ? undefined : getJsDoc(declarationNode, context.ts);
    const inheritedJsDocs = Array.from(inheritNodes.values())
        .filter(node => !isDeclarationExcluded(node, context))
        .map(n => getJsDoc(n, context.ts));
    const jsDoc = mergeJsDocs(mainJsDoc, inheritedJsDocs);
    // Expand members using jsdoc annotations and merge all members.
    const mergedMembers = mergeMembers(expandMembersFromJsDoc(members), context);
    // Merge slots, events and css properties
    const mergedSlots = mergeSlots(slots);
    const mergedEvents = mergeEvents(events);
    const mergedCSSProps = mergeCSSProps(cssProps);
    const className = (context.ts.isClassDeclaration(declarationNode) || context.ts.isInterfaceDeclaration(declarationNode)) && declarationNode.name != null
        ? declarationNode.name.text
        : undefined;
    return {
        node: declarationNode,
        members: mergedMembers,
        slots: mergedSlots,
        events: mergedEvents,
        cssProperties: mergedCSSProps,
        inheritNodes: Array.from(inheritNodes.values()),
        inherits: Array.from(inherits.values()),
        className,
        jsDoc
    };
}
/**
 * Function that tests if this declaration is excluded based on the configuration.
 * @param node
 * @param context
 */
function isDeclarationExcluded(node, context) {
    if (!context.ts.isClassLike(node) && !context.ts.isInterfaceDeclaration(node))
        return false;
    if (context.config.excludedDeclarationNames == null)
        return false;
    const name = (node.name != null && node.name.text) || "";
    // Test if the name is excluded
    return context.config.excludedDeclarationNames.includes(name);
}
/**
 * Visit a declaration and emits members through the context.
 * @param node
 * @param flavors
 * @param context
 */
function visitComponentDeclaration(node, flavors, context) {
    if (node == null)
        return [];
    const { ts } = context;
    // Skip visiting it's children if this name is excluded
    if (isDeclarationExcluded(node, context)) {
        return;
    }
    if (ts.isClassLike(node) || ts.isInterfaceDeclaration(node)) {
        // Visit inherited nodes
        visitInheritedComponentDeclarations(node, flavors, context);
    }
    // By default each flavor stops the parsing if it finds anything.
    // However each flavor has the ability to continue the recursion.
    // Emit members
    const membersResult = executeFirstFlavor(flavors, "parseDeclarationMembers", node, context);
    if (membersResult != null) {
        context.emitMembers(membersResult.result);
        if (!membersResult.shouldContinue)
            return;
    }
    // Emit events
    const eventsResult = executeFirstFlavor(flavors, "parseDeclarationEvents", node, context);
    if (eventsResult != null) {
        context.emitEvents(eventsResult.result);
        if (!eventsResult.shouldContinue)
            return;
    }
    // Emit css properties
    const cssPropertiesResult = executeFirstFlavor(flavors, "parseDeclarationCSSProps", node, context);
    if (cssPropertiesResult != null) {
        context.emitCSSProps(cssPropertiesResult.result);
        if (!cssPropertiesResult.shouldContinue)
            return;
    }
    // Emit slots
    const slotsResult = executeFirstFlavor(flavors, "parseDeclarationSlots", node, context);
    if (slotsResult != null) {
        context.emitSlots(slotsResult.result);
        if (!slotsResult.shouldContinue)
            return;
    }
    // Visit child nodes
    node.forEachChild(child => {
        visitComponentDeclaration(child, flavors, context);
    });
}
/**
 * This function call each flavor on a node until a flavor emits a result.
 * Each flavor has the ability to emit a "continue" instruction.
 * @param flavors
 * @param key
 * @param node
 * @param context
 */
function executeFirstFlavor(flavors, key, node, context) {
    // Loop through each flavor
    for (const flavor of flavors) {
        const func = flavor[key];
        if (func == null)
            continue;
        // Save a "continue" flag if necessary
        let shouldContinue = false;
        const result = func(node, Object.assign(Object.assign({}, context), { emitContinue() {
                shouldContinue = true;
            } }));
        // Return a result if not undefined
        if (result != null) {
            return { result: result, shouldContinue };
        }
    }
    return undefined;
}
/**
 * Visits and emit declaration members in each interface/class-like inherited node.
 * @param node
 * @param flavors
 * @param context
 */
function visitInheritedComponentDeclarations(node, flavors, context) {
    const { ts } = context;
    /*function go (n: Type) {
     if ("instantiations" in t) {
     const tt = t as ConditionalRoot;
     console.log(`ConditionalRoot: instantiations`);
     tt.instantiations!.forEach((value, key) => {
     console.log(key, context.checker.typeToString(value));
     go(value);
     });
     }
     }

     const t = context.checker.getTypeAtLocation(node);
     console.log("Type: ", context.checker.typeToString(t));
     go(t);*/
    if (node.heritageClauses != null) {
        for (const heritage of node.heritageClauses || []) {
            // class Test implements MyBase
            // Don't visit interfaces if we are looking at a class, because the class already declares all things from the interface
            if (ts.isClassLike(node) && heritage.token === ts.SyntaxKind.ImplementsKeyword) {
                for (const type of heritage.types) {
                    context.emitInheritNode(type.expression);
                    context.emitInherit(type.expression.getText());
                }
                continue;
            }
            // [extends|implements] MyBase
            for (const type of heritage.types) {
                resolveAndExtendHeritage(type.expression, flavors, context);
            }
        }
    }
}
function resolveAndExtendHeritage(node, flavors, context) {
    const { ts } = context;
    // Emit extends name
    context.emitInherit(node.getText());
    if (ts.isCallExpression(node)) {
        // Mixins
        const { expression: identifier, arguments: args } = node;
        // Extend classes given to the mixin
        // Example: class MyElement extends MyMixin(MyBase) --> MyBase
        // Example: class MyElement extends MyMixin(MyBase1, MyBase2) --> MyBase1, MyBase2
        for (const argument of args) {
            resolveAndExtendHeritage(argument, flavors, context);
        }
        // Resolve and traverse the mixin function
        // Example: class MyElement extends MyMixin(MyBase) --> MyMixin
        if (identifier != null) {
            const declarations = resolveDeclarations(identifier, context);
            for (const declaration of declarations) {
                // Extend right away if the node is a class declaration
                if (ts.isClassLike(declaration)) {
                    extendWithDeclarationNode(declaration, flavors, context);
                    return;
                }
                // Else find the first class declaration in the block
                // Note that we don't look for a return statement because this would complicate things
                const clzDecl = findChild(declaration, ts.isClassLike);
                if (clzDecl != null) {
                    extendWithDeclarationNode(clzDecl, flavors, context);
                    return;
                }
                // If we didn't find any class declarations, we might be in a function that wraps a mixin
                // Therefore find the return statement and call this method recursively
                const returnNode = findChild(declaration, ts.isReturnStatement);
                if (returnNode != null && returnNode.expression != null && returnNode.expression !== node) {
                    resolveAndExtendHeritage(returnNode.expression, flavors, context);
                    return;
                }
            }
        }
    }
    else {
        const declarations = resolveDeclarations(node, context);
        // Visit component declarations for each inherited node.
        for (const declaration of declarations) {
            extendWithDeclarationNode(declaration, flavors, context);
        }
    }
}
function extendWithDeclarationNode(declaration, flavors, context) {
    const { ts } = context;
    if (ts.isInterfaceDeclaration(declaration) || ts.isClassLike(declaration)) {
        context.emitInheritNode(declaration);
    }
    if (context.config.analyzeLibDom || !isNodeInLibDom(declaration)) {
        visitComponentDeclaration(declaration, flavors, context);
    }
}
