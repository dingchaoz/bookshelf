import { toTypeString } from "ts-simple-type";
import { flatten } from "../../util";
/**
 * Transforms results to json.
 * @param results
 * @param program
 * @param config
 */
export function jsonTransformer(results, program, config) {
    const checker = program.getTypeChecker();
    // Get all definitions
    const definitions = flatten(results.map(res => res.componentDefinitions));
    // Transform all definitions into "tags"
    const tags = definitions.map(d => definitionToHtmlDataTag(d, checker));
    const htmlData = {
        version: 2,
        tags
    };
    return JSON.stringify(htmlData, null, 2);
}
function definitionToHtmlDataTag(definition, checker) {
    const attributes = definition.declaration.members
        .map(d => componentMemberToHtmlDataAttribute(d, checker))
        .filter((val) => val != null);
    const properties = definition.declaration.members
        .map(d => componentMemberToHtmlDataProperty(d, checker))
        .filter((val) => val != null);
    const events = definition.declaration.events
        .map(e => componentEventToHtmlDataEvent(e, checker))
        .filter((val) => val != null);
    const slots = definition.declaration.slots
        .map(e => componentSlotToHtmlDataSlot(e, checker))
        .filter((val) => val != null);
    const cssProperties = definition.declaration.cssProperties
        .map(p => componentCssPropToHtmlCssProp(p, checker))
        .filter((val) => val != null);
    return {
        name: definition.tagName,
        description: getDescriptionFromJsDoc(definition.declaration.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(definition.declaration.jsDoc),
        attributes,
        properties,
        events,
        slots,
        cssProperties
    };
}
function componentCssPropToHtmlCssProp(prop, checker) {
    return {
        name: prop.name || "",
        description: getDescriptionFromJsDoc(prop.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(prop.jsDoc)
    };
}
function componentSlotToHtmlDataSlot(slot, checker) {
    return {
        name: slot.name || "",
        description: getDescriptionFromJsDoc(slot.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(slot.jsDoc)
    };
}
function componentEventToHtmlDataEvent(event, checker) {
    return {
        name: event.name,
        description: getDescriptionFromJsDoc(event.jsDoc),
        jsDoc: getJsDocTextFromJsDoc(event.jsDoc)
    };
}
function componentMemberToHtmlDataAttribute(member, checker) {
    switch (member.kind) {
        case "attribute":
        case "property":
            if (member.attrName == null) {
                return undefined;
            }
            return {
                name: member.attrName,
                description: getDescriptionFromJsDoc(member.jsDoc),
                jsDoc: getJsDocTextFromJsDoc(member.jsDoc),
                type: getJsDocTypeFromType(member.type, checker)
            };
    }
    return undefined;
}
function componentMemberToHtmlDataProperty(member, checker) {
    switch (member.kind) {
        case "property":
            return {
                name: member.propName,
                description: getDescriptionFromJsDoc(member.jsDoc),
                jsDoc: getJsDocTextFromJsDoc(member.jsDoc),
                type: getJsDocTypeFromType(member.type, checker)
            };
    }
    return undefined;
}
function getDescriptionFromJsDoc(jsDoc) {
    return jsDoc != null ? jsDoc.comment : undefined;
}
function getJsDocTextFromJsDoc(jsDoc) {
    return jsDoc != null && jsDoc.node != null ? jsDoc.node.getText() : undefined;
}
function getJsDocTypeFromType(type, checker) {
    if (type == null)
        return undefined;
    // This function needs to return a jsdoc compatible type representation
    //   but "checker.typeToString" doesn't do that.
    return isTypescriptType(type) ? checker.typeToString(type) : toTypeString(type);
}
function isTypescriptType(value) {
    return value instanceof Object && "flags" in value && "checker" in value;
}
